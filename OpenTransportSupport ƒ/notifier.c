/*  $Log: notifier.c,v $  Revision 1.3  2003/10/12 22:44:24  gtbyers  Use #_OTAllocMemInContext, #_OTAllocInContext instead of legacy versions.  No other change, but at least this builds in Carbon ...  Revision 1.2  2002/12/01 02:21:56  gtbyers  no real change: CVS log entry  12/10/99 slh  do_rcv: add kOTCanceledErr case alongside kOTOutStateErr  05/03/99  kr  Change ++ increment to OTAtomicAdd32  03/29/97  gb  so much for ot_client_notifier.  Clear OT_FLAG_INCOMING_CONNECTION_ALLOWED                when kOTProviderWillClose event arrives.  03/13/97  gb  handle kOTProviderWillClose; ot_client_notifier for debugging                the OTRegisterAsClient call.  02/16/97  gb  don't defer T_ORDREL in do_rcv.  Don't debugstr & proceed;                acknowledge the orderly release, then try again.  01/13/97  gb  don't ignore T_CONNECT.                Initialize client->client_call's address when doing                #_OTAccept, so lisp can find peer address.                Bump version to 2.0.  12/10/96  gb  don't defer T_DISCONNECT messages in do_rcv;                DebugStr & proceed if we get a T_ORDREL.  12/07/96  gb  lotsa changes: one notifier, handles multiple incoming                requests, more error checking, etc.                Define (& export) OpenTransportSupportVersion.  11/26/96  gb  qbuf.flags; ot_context.sendcount, ot_context.ackcount.                Build with OT 1.1.1 libraries & headers.                Doesn't handle kProviderWillClose, but doesn't think                that it's a completion event either.  11/16/96  gb  new "proxy" listen scheme; changes in ot_context format.  11/06/96  gb  enqueue the OTBuffer (in minimal "fake" qbuf) when                OTAllocMem fails.  Add dprintf(), more DebugStr calls.*/#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OSUtils.h>#include <stdlib.h>#include <stdarg.h>#include <stddef.h>#define MAKE_VERSION(major,minor,rev,stage,release) \  (((major)<<24) | ((minor) << 20) | ((rev) << 16) | ((stage) << 8) | (release))unsignedOpenTransportSupportVersion = MAKE_VERSION(MAJOR,MINOR,0,0,0);/*  This -must- exactly match the lisp record definition.*/typedef struct qbuf {  QElemPtr qLink;  short qType;  short flags;  unsigned  bufcount;  char bufdata[1];} qbuf;#define QBUF_FLAGS_ALLOC_MASK 0x3#define QBUF_FLAGS_ALLOC_SHARED 0x0 /* part of some other structure, don't dispose */#define QBUF_FLAGS_ALLOC_OTALLOC 0x1 /* could dispose via OTFreeMem() */#define QBUF_FLAGS_ALLOC_NEWPTR 0x2 /* could dispose via DisposePtr() */typedef struct incon_request incon_request;typedef struct ot_context{  EndpointRef ref;  Boolean completed;  Boolean peerclosed;  Boolean selfclosed;  Boolean closing;  unsigned short flags;  Boolean synch;                /* endpoint in synch mode ? */  Boolean pad;  void *cookie;  OTEventCode code;  OTResult result;  QHdrPtr wrQ;  QHdrPtr rdQ;  incon_request *request;  QElemPtr qLink;  short qType;  short pad0;  unsigned long sendcount;  signed long ackcount;  TCall *client_call;} ot_context;#define proxy_incon_pool(proxy_context) ((QHdrPtr)((proxy_context)->sendcount))#define OT_FLAG_DATA_PENDING (1<<0)#define OT_FLAG_DEBUG_NOTIFIER (1<<15)#define OT_FLAG_INCOMING_CONNECTION (1<<14)#define OT_FLAG_INCOMING_CONNECTION_ALLOWED (1<<13)#define OT_FLAG_PROXY_CONTEXT (1<<1)struct incon_request {  QElemPtr qLink;  short qType;  short pad;  ot_context *client;  ot_context *proxy;  TCall *call;  QHdrPtr pool;                 /* where this comes from & returns to */};#define maybe_debug(codeval) do { if (debug && (code == codeval)) {DebugStr("\p" ## #codeval);}} while (0)pascal voidot_stream_notifier(ot_context *, OTEventCode, OTResult, void *);QElemPtrqpop(QHdrPtr head){  /* Atomically pop the first element off of the q header.     "Popping" happens atomically, but we can't be sure that     someone else doesn't pop while we're figuring out what     to pop.  We can tell if they've done so, so we try again */  QElemPtr q;  while ((q = head->qHead) != NULL) {    if (Dequeue(q, head) == noErr) break;  }  return q;}incon_request *alloc_incon_request(ot_context *proxy){  QHdrPtr pool = proxy_incon_pool(proxy);  incon_request *r;  OSStatus err;  TCall * call;  r = (incon_request *) OTAllocMemInContext(sizeof(incon_request), NULL);  if (r != NULL) {    call = OTAllocInContext(proxy->ref, T_CALL, T_ADDR, &err, NULL);    if (err != kOTNoError) {      OTFreeMem(r);      r = NULL;    } else {      r->qLink = NULL;      r->qType = 0;      r->pad = 0;      r->call = call;      r->pool = pool;      r->client = r->proxy = NULL;    }  }  return r;}incon_request *get_incon_request(ot_context *proxy){  QHdrPtr pool = proxy_incon_pool(proxy);  incon_request *r = (incon_request *) qpop(pool);  if (r == NULL) {    r = alloc_incon_request(proxy);  }  if (r) {    r->client = r->proxy = NULL;  }  return r;}voidreturn_incon_request(incon_request *r){  Enqueue((QElemPtr)r, r->pool);}/* Queue of client contexts willing to listen */#define WAITQ(context) (context)->wrQvoidreturn_client(ot_context *client, ot_context *proxy){  client->request = NULL;  Enqueue((QElemPtr) (((int)client) + offsetof(ot_context, qLink)), WAITQ(proxy));}ot_context *get_client(ot_context *proxy){  QElemPtr q = qpop(WAITQ(proxy));  if (q != NULL) {    return (ot_context *) (((int)q) - offsetof(ot_context, qLink));  }  return (ot_context *) NULL;}intdprintf(const char *fmt, ...){  va_list args;  Str255 buf;  int ret;      va_start(args, fmt);  ret = vsprintf((char *)(buf+1),fmt,args);  buf[0] = ret;  DebugStr(buf);  return ret;}static qbuf*get_buffer(unsigned size){  unsigned total = size + offsetof(qbuf, bufdata);  qbuf *q = (qbuf *) OTAllocMemInContext(total, NULL);    if (q) {    q->qType = 0;    q->qLink = NULL;    q->flags = QBUF_FLAGS_ALLOC_OTALLOC;    q->bufcount = size;  }  return q;}/*  If we got a kOTLookErr on endpoint ep, call OTLook().  If the corresponding  event code is set in "mask", try to handle the event here and return 0.  If the event is not masked, or if there's no simple way of handling it,  return the event code. */#define OT_SIMPLE_EVENTS (T_GODATA|T_GOEXDATA)OTEventCodedo_look(EndpointRef ep, OTEventCode mask){  OTEventCode pending = OTLook(ep);    if ((pending & mask) == 0) {    return pending;  }  switch (pending) {    /* These guys are cleared just by looking at them. */  case T_GODATA:  case T_GOEXDATA:    return 0;  case T_DISCONNECT:    OTRcvDisconnect(ep, NULL);    return 0;    /* Other cases (notably T_LISTEN) require non-trivial handling) */  case T_LISTEN:  default:    return pending;  }}voidhandle_stream_disconnect(ot_context *context){  OTRcvDisconnect(context->ref, NULL);  context->peerclosed = context->selfclosed = true;}voiddo_rcv(ot_context *context){  Boolean     debug = ((context->flags & OT_FLAG_DEBUG_NOTIFIER) != 0);  OTResult result;    /* If "closing" flag is set, consume any     outstanding unread data */  if (context->closing) {    context->flags &= ~(OT_FLAG_DATA_PENDING);    do {      char drain[512];      result = OTRcv(context->ref, drain, sizeof(drain), NULL);    } while (result >= 0);  } else {    if (context->flags & OT_FLAG_INCOMING_CONNECTION_ALLOWED) {      /* We can get a T_DATA before getting T_PASSCON */      context->flags |= OT_FLAG_DATA_PENDING;      if (debug) {        dprintf("Data arrived before connection established!");      }    } else {      OTBuffer *the_OTBuffer;      OTBufferInfo the_buffer_info;      OTFlags flags = (OTFlags) 0;      OTResult status;      size_t count;      qbuf *q;      Boolean done = false;      context->pad0++;          /* At least one call to OTRcv(... */            if (debug) {        dprintf("Doing no-copy RCV");      }      do {        status = OTRcv(context->ref, &the_OTBuffer, kOTNetbufDataIsOTBufferStar, &flags);        if (status == kOTNoDataErr) {          done = true;        } else if (status > 0) {          count = (size_t)status;          if ((q = get_buffer(count)) == NULL) {            if ((q = get_buffer(sizeof(OTBuffer **))) == NULL) {              dprintf("You're losing REAL BAD!");              break;            }            q->bufcount = 0;    /* flag it as fake */            *((OTBuffer **)(q->bufdata)) = the_OTBuffer;                    } else {            OTInitBufferInfo(&the_buffer_info, the_OTBuffer);            OTReadBuffer(&the_buffer_info, q->bufdata, &count);            if (debug) {              dprintf("OTReadBuffer - expected %d. bytes, read %d. bytes.", status, count);            }            OTReleaseBuffer(the_OTBuffer);          }          Enqueue((QElemPtr)q, context->rdQ);        } else if (status == kOTLookErr) {          /* What's the big deal ? */          OTEventCode the_big_deal = do_look(context->ref, OT_SIMPLE_EVENTS);          /* Oh. */          switch (the_big_deal) {          case T_ORDREL:            OTRcvOrderlyDisconnect(context->ref); /* Tell OT that we heard it. */            context->peerclosed = true;            break;                        case T_DISCONNECT:            handle_stream_disconnect(context);            break;          }        } else {          switch (status) {          case kOTOutStateErr:          case kOTCanceledErr:            done = true;            break;                        default:            dprintf("Error from OTRcv: status = %d", status);          }        }      } while (! done);    }  }}/* Queue of incon_requests that need further processing */#define INCONQ(context) (context)->rdQ/*   This is supposed to more-or-less match the step-by-step  recipe in TN 1059.  Left unsaid (at least explicitly) there & elsewhere is  the fact that there can be only one outstanding call to  #_OTAccept or #_OTSndDisconnect at any time, and this  restriction is enforced by Open Transport.  We use the  ot_context.request slot of the proxy and client context  records to hold that outstanding request until the  completion event(s) arrive; those completion events will  generally call back here to handle the next pending  #_OTAccept or #_OTSndDisconnect, secure in the knowledge  that nothing else could start one in the meantime.  Clients are enqueued in the proxy context's WAITQ.  They're put there by lisp code; this code & the notifier  may also return them there if an #_OTAccept in which they're  involved fails.  incon_requests are preallocated in the proxy's proxy_incon_pool.  Each successful #_OTListen call puts an incon_request (with its  TCall structure) on the proxy context's INCONQ.  When we've gotten all of the oustanding #_OTListen results, we  process each of them one at a time.  If we can dequeue a client  record, we associate it with the incon_request and prepare to  call #_OTAccept; otherwise, we must reject the connection and  prepare to call #_OTSndDisconnect to do so.  We process each request by making it the value of the proxy's  ot_context.request slot (and, if we have a client, doing the  same to the client.)  If we can successfully start the #_OTAccept/  #_OTSndDisconenct, we remove the request from the incon; otherwise,  we "forget what's current" and #_OTLook to see what the fuss is about.  If we successfully started the accept/disconnect, we can return: we  can't process another one until the outstanding event is complete,  and we use the completion handlers for the events in question to get  us back to this dispatching step.  When a disconnect completes, we can return the request record to the  pool and dispatch on the next request in the INCONQ.  When an accept  completes with an error, we'll get a T_ACCEPTCOMPLETE (with a non-zero  result parameter) in the proxy's notifier and will never get a  T_PASSCON for the client.  T_ACCEPTCOMPLETE aborts the connection with  a #_OTSndDisconnect, and the T_DISCONNECT handler returns the request  (and T_ACCEPTCOMPLETE returns the client in this case.)  Note that if  the client's really bogus (endpoint bound to the wrong address,  already connected, endpoint closed) it's likely to fail again; we have  to put'em -somewhere-, and back on the WAITQ seems as good a place as  any.    If the T_ACCEPTCOMPLETE gets a result = to #$kOTNoError, there'll be  a T_PASSCON event (with the client context) as well, but it's not  defined which of these happens first.  Both cases have to accept the  possibility that they're first (mark things so the other guy can tell)  or second (return the request and repeat the state machine's dispatch  step).  Both events have to arrive before it's OK to repeat that  dispatch step.  */voidincon_state_machine(ot_context *context, int step){  Boolean debug = ((context->flags & OT_FLAG_DEBUG_NOTIFIER) != 0);  EndpointRef ep = (context->ref);  OSStatus status;  TCall *call = NULL;  QHdrPtr clients = WAITQ(context), incon = INCONQ(context);  ot_context* client = NULL;  incon_request *r;  OTEventCode pending;  while (step != 0) {    if (debug) {      dprintf("State machine: step = %d", step);    }    switch (step) {    case 1:      /* Call OTListen() in a loop, until we get a kOTNoDataErr (no more requests)         or a kOTLookErr (something more important is happening, I guess.)          Enqueue any incon_requests to the INCONQ. */      do {        r = get_incon_request(context);        if (r == NULL) {          dprintf("Out of memory!");          return;        }        status = OTListen(ep, r->call);        if (status == kOTNoError) {          Enqueue((QElemPtr)r, incon);        } else {          return_incon_request(r);          if (status == kOTLookErr) {            pending = OTLook(ep);            if (pending == T_DISCONNECT) {              step = 2;            }          }           if (step == 1) {            step = 3;          }        }      } while (step == 1);      break;    case 2:      {        TDiscon discon;        OTSequence seq;        discon.udata.len = discon.udata.maxlen = 0;        discon.udata.buf = NULL;        discon.sequence = (OTSequence) 0;        discon.reason = (OTReason) 0;                OTRcvDisconnect(ep, &discon);        seq = discon.sequence;        /* Find an incon_request whose TCall's sequence number           matches seq.  Delete it from the inconq, returning           the incon_request and the client (if there is one)           to their queues. */        for (r = (incon_request *) incon->qHead; r; r = (incon_request *) r->qLink) {          if (seq == r->call->sequence) {            Dequeue((QElemPtr)r, incon);            client = r->client;            if (client) {              return_client(client, context);            }            /* If we're expecting this request to be completed, stop waiting. */            if (context->request == r) {              context->request = NULL;            }            return_incon_request(r);            break;          }        }      }      step = 1;      break;          case 3:      r = (incon_request *) incon->qHead;      if (r == NULL) {        step = 0;      } else {        r->client = get_client(context);        if (r->client) {          step = 4;        } else step = 5;      }      break;    case 4:      /* Try to accept what's on the front of the inconq */            client = r->client;      context->request = r;      client->request = r;      {        TCall *client_call = client->client_call;        size_t n = r->call->addr.len;                client_call->addr.len = n;        BlockMoveData(r->call->addr.buf, client_call->addr.buf, n);      }           status = OTAccept(ep, client->ref, r->call);            if (status == kOTLookErr) {        context->request = NULL;        pending = OTLook(ep);        if (pending == T_LISTEN) {          step = 1;        } else step = 2;        /* T_DISCONNECT */      } else {        Dequeue((QElemPtr)r, incon); /* may already be enqueued elsewhere */        step = 0;      }      break;    case 5:      context->request = r;      status = OTSndDisconnect(ep, r->call);      if (status == kOTLookErr) {        pending = OTLook(ep);        if (pending == T_DISCONNECT) {          step = 2;        }      } else {        /* context->ackcount++; */		OTAtomicAdd32(1,&(context->ackcount));        Dequeue((QElemPtr)r, incon); /* may already be enqueued elsewhere */        step = 0;      }      break;    }  }  return;}pascal voidot_stream_notifier(ot_context *context, OTEventCode code, OTResult result, void *cookie){  Boolean     debug = ((context->flags & OT_FLAG_DEBUG_NOTIFIER) != 0),    is_proxy = ((context->flags & OT_FLAG_PROXY_CONTEXT) != 0),    is_completion_event = IsOTCompleteEvent(code);  ot_context *client;  incon_request *r;  if (debug) {    maybe_debug(T_DISCONNECT);    maybe_debug(T_DISCONNECTCOMPLETE);    maybe_debug(T_ORDREL);    maybe_debug(T_EXDATA);    maybe_debug(T_DATA);    maybe_debug(T_OPENCOMPLETE);    maybe_debug(T_ACCEPTCOMPLETE);    maybe_debug(T_BINDCOMPLETE);    maybe_debug(T_UNBINDCOMPLETE);    maybe_debug(T_CONNECT);    maybe_debug(T_PASSCON);    maybe_debug(T_GETPROTADDRCOMPLETE);    maybe_debug(kOTProviderWillClose);    maybe_debug(T_OPTMGMTCOMPLETE);    maybe_debug(T_DNRSTRINGTOADDRCOMPLETE);    maybe_debug(T_DNRADDRTONAMECOMPLETE);  }  switch (code) {  case T_DISCONNECT:    if (is_proxy) {      incon_state_machine(context, 2);    } else {      /* "disorderly" disconnect from peer, or         rejected connection.         Acknowledge it. */      if (cookie != NULL) {        /* This was a rejected connection attempt. */        TDiscon discon;                discon.udata.len = discon.udata.maxlen = 0;        discon.udata.buf = NULL;        discon.sequence = (OTSequence) 0;        discon.reason = (OTReason) 0;                OTRcvDisconnect(context->ref, &discon);        if (debug) {          DebugStr("\pCheck discon.reason!");        }        /* active-open code has been waiting for completion */        context->result = (OTResult) discon.reason;        context->code = code;        context->cookie = cookie;        context->peerclosed = true;        context->completed = true;      } else {        /* A connection that was up is now down.  Nobody's           (necessarily) been waiting for this.  Set both the           selfclosed and peerclosed flags. */        handle_stream_disconnect(context);      }    }    break;    /* It seems that one gets one or the other of these, but not both.       It's not clear to me whether we're running at SystemTask time       in all cases, so we can't do too much here.       */  case kOTProviderIsClosed:    /* I'm not sure that we're at SystemTask time here */      case kOTProviderWillClose:    /* The notifier is (supposedly) running at SystemTask time (not       at interrupt time).  When we return from the notifier, the       endpoint'll have entered the T_UNINIT state.  Anything waiting       for completion should stop doing so, since the endpoint is       basically dead. */    OTSetSynchronous(context->ref);    context->synch = true;    if (is_proxy) {      /* Not much to do but to empty the queue here */      ot_context *junk;            if (debug) {        dprintf("proxy closed");      }      do {        junk = get_client(context);      } while (junk != NULL);    } else {      if (debug) {        dprintf("Client closed");      }      context->flags &= ~(OT_FLAG_INCOMING_CONNECTION_ALLOWED);    }    context->completed = true;    break;  case T_LISTEN:    if (is_proxy) {      incon_state_machine(context, 1);    }    /* Doesn't make sense to get a T_LISTEN on a client */    break;      case T_ORDREL:    /* Only makes sense to get a T_ORDREL on a client */    if (!is_proxy) {      /* We've received all that the peer's going to send us.         That's -all- that this means; if we've already sent         an orderly disconnect to the peer, the connection's         now closed, but it's not this code's business to send         a disconnect now. */      OTRcvOrderlyDisconnect(context->ref); /* Tell OT that we heard it. */      context->peerclosed = true;    }    break;  case T_MEMORYRELEASED:    if (! is_proxy) {      qbuf *q = (qbuf *)(((char *)(cookie)) - offsetof(qbuf, bufdata));      if (debug) {        dprintf("Buffer released - #x%08x", cookie);      }      Enqueue((QElemPtr)q, context->wrQ);	  /* context->ackcount++; */		OTAtomicAdd32(1,&(context->ackcount));    }    break;      case T_ACCEPTCOMPLETE:    /* This and T_PASSCON can happen at about the same time if the       OTAccept wins.       When OTAccept was called, both the proxy context and the client       context had the same request record.       T_ACCEPTCOMPLETE removes the request record from the proxy context.       If it's still present in the client context, T_ACCEPTCOMPLETE will       put a pointer to the proxy context in the request's proxy slot to       signal T_PASSCON that it happened last.       The handler for whichever event happens last has to return the       request record and run the queue.       Of course, if T_ACCEPTCOMPLETE gets an error return, it should       free the request and send a disconnect; that'll run the queue       if it completes successfully via T_DISCONNECTCOMPLETE. */    r = context->request;    context->request = NULL;    client = r->client;    if (result == kOTNoError) {      if (client->request == NULL) {        return_incon_request(r);        incon_state_machine(context, 3);      } else {        r->proxy = context;     /* let T_PASSCON return the request & run the queue */      }    } else {      return_client(client, context);      OTSndDisconnect(context->ref, r->call);      /* context->ackcount += 0x10000; */	  OTAtomicAdd32(0x10000,&(context->ackcount));      return_incon_request(r);    }    is_completion_event = false;    break;  case T_PASSCON:    /* We're no longer waiting for a passive connection. */    {      ot_context *proxy;      r = context->request;      context->request = NULL;      proxy = r->proxy;      if (proxy != NULL) {        return_incon_request(r);        incon_state_machine(proxy, 3);      }      context->flags &= ~OT_FLAG_INCOMING_CONNECTION_ALLOWED;      if (context->flags & OT_FLAG_DATA_PENDING) {        context->flags &= ~OT_FLAG_DATA_PENDING;        do_rcv(context);      }    }    break;        /* We should find some way to fit "expedited" data into the       paradigm. */      case T_EXDATA:  case T_DATA:    do_rcv(context);    break;  case T_DISCONNECTCOMPLETE:    /* This means something different to the proxy than it does to the client */    if (is_proxy) {      r = context->request;      context->request = NULL;      return_incon_request(r);      incon_state_machine(context, 3);    } else {      /* If we initiated a disconnect via OTSndDisconnect(), it's         now complete.  Set both the peerclosed and the selfclosed         flags. */      context->peerclosed = context->selfclosed = true;    }    break;  case T_DNRSTRINGTOADDRCOMPLETE:  case T_DNRADDRTONAMECOMPLETE:    /* These are really completion events; I don't know why       they aren't encoded that way. */    is_completion_event = true;    break;   case T_BINDCOMPLETE:    if (is_proxy && (result == kOTNoError)) {      TBind *bindret = (TBind *) cookie;      int i, n = bindret->qlen;      QHdrPtr header = OTAllocMemInContext(sizeof(QHdr), NULL);            if (n < 10) {        n = 10;      } else {        n = n+n;      }      if (header == NULL) {        result = kENOMEMErr;      } else {        header->qHead = header->qTail = NULL;        header->qFlags = 0;        proxy_incon_pool(context) = header;        for (i = 0; i < n; i++) {          r = alloc_incon_request(context);          if (r == NULL) {            break;          } else {            return_incon_request(r);          }        }      }    }    break;      case T_CONNECT:    is_completion_event = true;    break;  }    if (is_completion_event) {    context->completed = true;    context->code = code;    context->result = result;    context->cookie = cookie;  }}/* Experimental, at this point.  OT never seems to call it.pascal voidot_client_notifier(void *param, OTEventCode code, OTResult result, void * cookie){  dprintf("param = #x%08x, code = #x%08x, result = %d, cookie = #x%08x;g", param, code, result, cookie);}*/