;;;-*- Mode: Lisp; Package: CCL -*-;;;;;; ae-text-suite.lisp;;;;;; Provides basic support for the Text AppleEvents suite by defining common ;;; event handlers and classes in the suite.;;; Can be specialized for applications or used as is with MCL.;;;;;; Copyright © 1999-2010 Terje Norderhaug and Media Design in¥Progress;;;;;; Version: 1.0;;;;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as this copyright ;;; notice is left intact in the source code.;;;;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;;;;; Author: Terje Norderhaug <terje@in-progress.com> of Media Design in¥Progress.;;;;;; The most recent version of this module is available from:;;; <http://www.in-progress.com/src/>;;;;;;;;; Note that to get full benefit of this module, MCL (or your application) ;;; should have an AETE resource with a definition for the Text suite.;;; Without an AETE resource only some of the commands will work from AppleScript,;;; and even those that work will have limited arguments.(in-package :ccl);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; LINE(define-ae-object-class line ()  (:ostype #$cLine)  (:accessor line-reference-accessor)) (defclass line-reference (document-content-range)  ())(defmethod line-reference-accessor ((container application) keyform keydata)  (line-reference-accessor (front-window) keyform keydata))     (defmethod line-reference-accessor ((container window) keyForm keyData)  (case keyForm     (:absolute-position       (let ((index (get-keydata-value :absolute-position keydata)))          (make-instance 'line-reference            :container container            :first index            :last index)))     (:range       (multiple-value-bind (first last)          (get-keydata-value :range keydata)          (make-instance 'line-reference            :container container            :first first            :last last)))     (otherwise       (error 'keyform-not-supported :keyform keyform))))(defmethod ae-count ((window window) (type (eql #.#$cLine)))  (lines-in-buffer (fred-buffer window)))(defmethod (setf property-value) (aedesc (reference line-reference))  (multiple-value-bind (start end) (character-range reference)    (let* ((window (content-window reference))           (buffer (fred-buffer window)))      (buffer-delete buffer start end)      (buffer-insert buffer        (ecase (pref aedesc :aedesc.descriptortype)          (#.#$typeObjectSpecifier            (property-value (resolve-object-specifier aedesc)))          (#.#$typeChar           (let ((data-size (#_aegetdescdatasize aedesc)))             (%stack-block ((data-ptr data-size))               (errchk (#_aegetdescdata aedesc data-ptr data-size))               (%str-from-ptr-in-script data-ptr data-size)))))         start)      (fred-update window))))(defmethod get-property-value ((label (eql #$pJustification)) object)  (let ((window (content-window object)))    (ecase (fred-justification window)      ((NIL :left) #$kAELeftJustified)      (:right #$kAERightJustified)      (:center #$kAEFullyJustified))))(defmethod set-property-value ((label (eql #$pJustification)) (object line-reference) aedesc)  ;; Should apply to line not to window!  (let ((window (content-window object))        (justification (ae-get-desc-data aedesc)))    (setf (fred-justification window)      (ecase justification        (#.#$kAELeftJustified :left)        (#.#$kAERightJustified :right)        (#.#$kAEFullyJustified :center)))    (fred-update window)))(defmethod character-range ((lines line-reference))  (let* ((window (content-window lines))         (buffer (fred-buffer window)))    (multiple-value-bind (container-start container-end)      (character-range (slot-value lines 'container))      (with-slots (first last) lines        (if (eq first :middle)          (let ((middle (floor (buffer-count-char buffer #\Newline container-start container-end) 2)))            (values               (buffer-line-start buffer container-start middle)              (buffer-line-end buffer container-start middle)))          (values            (buffer-line-start buffer container-start (1- first))            (buffer-line-end buffer container-start (1- last))))))))(defmethod insertion-position ((base line-reference) position)   (with-slots (first last container) base     (let* ((window (content-window base))            (buffer (fred-buffer window)))       (etypecase position         (keyword           (case position             (:before (buffer-line-start buffer 0 (1- first)))             (:after (buffer-line-end buffer 0 (1- last)))))         (number           (if (plusp position)             (buffer-line-start buffer 0 (+ first position))             (buffer-line-start buffer 0 (+ last position))))))))        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PARAGRAPH(define-ae-object-class paragraph ()  (:ostype #$cParagraph)  (:accessor paragraph-reference-accessor)) (defclass paragraph-reference (document-content-range)  ())(defmethod paragraph-reference-accessor ((container application) keyform keydata)  (paragraph-reference-accessor (front-window) keyform keydata))(defmethod paragraph-reference-accessor ((container window) keyForm keyData)  (declare (ignore keydata))  (error 'keyform-not-supported :keyform keyform))(defmethod paragraph-reference-accessor ((container paragraph-reference) (keyForm (eql :relative-position)) keyData)  (let ((relation (get-keydata-value :relative-position keydata)))    (with-slots (container first last)      container      (let ((position (case relation (:previous (1- first))(:next (1+ (or last first))))))        (make-instance 'paragraph-reference          :container container          :first position          :last position)))))(defmethod paragraph-reference-accessor ((container window) (keyForm (eql :absolute-position)) keyData)  (let ((index (get-keydata-value :absolute-position keydata)))    (make-instance 'paragraph-reference      :container container      :first index      :last index)))(defmethod paragraph-reference-accessor ((container window) (keyForm (eql :range)) keyData)  (multiple-value-bind (first last)    (get-keydata-value :range keydata)    (make-instance 'paragraph-reference      :container container      :first first      :last last)))(defmethod line-reference-accessor ((container paragraph-reference) (keyForm (eql :absolute-position)) keyData)  (let ((index (get-keydata-value :absolute-position keydata)))    (make-instance 'line-reference      :container container      :first index      :last index)))(defmethod ae-count ((window window) (type (eql #.#$cParagraph)))  (ae-count (fred-buffer window) type))(defmethod ae-count ((buffer buffer-mark) (type (eql #.#$cParagraph)))    (do ((count 0 (1+ count))         (position (buffer-paragraph-start buffer 0 0)                   (buffer-paragraph-start buffer position 1)))        ((null position) count)))(defmethod ae-count ((container paragraph-reference) (type (eql #.#$cLine)))  (multiple-value-bind (start end) (character-range container)    (1+ (buffer-count-char (fred-buffer (content-window container)) #\Newline start end))))(defun buffer-paragraph-start (buffer-mark &optional (position 0) (count 0))  "Returns the position of the start of the paragraph at position in buffer-mark. count maybe used to find the start of previous or subsequent paragraphs."  (cond    ((zerop count)      (loop        until (= position 0)        for c = (buffer-char buffer-mark position)        do (if (and (eq #\newline c)                    (eq #\newline (buffer-char buffer-mark (1- position))))             (return-from buffer-paragraph-start (1+ position))             (decf position))       finally (return-from buffer-paragraph-start 0)))   ((plusp count)     (do ()         ((= (buffer-size buffer-mark)             (setf position (buffer-paragraph-end buffer-mark position 0))) NIL)      (decf count)      (loop        for c = (buffer-char buffer-mark position)        until (= position (buffer-size buffer-mark))        while (and c (whitespacep c))        do (incf position)        finally (when (and c (= count 0))                  (return-from buffer-paragraph-start                     (unless (= (buffer-size buffer-mark) position)                       position))))))   ((minusp count) ;; quick implementation, can be speeded up with more code      (let ((index (+ (ae-count buffer-mark #$cParagraph) count)))        (buffer-paragraph-start buffer-mark position index)))))  (defun buffer-paragraph-end (buffer &optional (position 0) (count 0))  "Returns the position after the last character of paragraph at position in buffer-mark. count maybe used to find the end of previous (not yet) or subsequent paragraphs."  (assert (not (minusp count)))  ;; ## Optimize by not open stream  (with-open-stream (in (make-instance 'buffer-stream :buffer buffer :start position))    (peek-char T in nil)    (loop      for position = (stream-position in)      until (>= position (buffer-size buffer))      for line = (read-line in nil)      while line      do (when (or (equal line "")                   (not (find-if-not #'whitespacep line)))           (if (= count 0)             (return-from buffer-paragraph-end (1- position))             (decf count)))     finally (when (= count 0)               (return-from buffer-paragraph-end position)))))(defmethod character-range ((paragraphs paragraph-reference))  (with-slots (first last) paragraphs   (let* ((window (content-window paragraphs))          (first (if (numberp first) first (slot-value first 'first)))          (last (if (numberp last) last (slot-value last 'last)))           (buffer (fred-buffer window))          (start-paragraph             (buffer-paragraph-start buffer 0               (if (plusp first) (1- first) first)))          (end-paragraph            (when start-paragraph              (buffer-paragraph-end buffer start-paragraph (- last first)))))       (if (and start-paragraph end-paragraph)        (values start-paragraph end-paragraph)        (error "Reference beyond last paragraph")))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TEXT; Covered in CORE suite;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; WORD(define-ae-object-class paragraph ()  (:ostype #$cWord)  (:accessor word-reference-accessor))(defclass word-reference (document-content-range)  ())(defmethod word-reference-accessor (container keyForm keyData)  "A lot of containers can have words"  (case keyForm     (:absolute-position       (let ((index (get-keydata-value :absolute-position keydata)))          (make-instance 'word-reference            :container container            :first index            :last index)))     (:range       (multiple-value-bind (first last)          (get-keydata-value :range keydata)          (make-instance 'word-reference            :container container            :first first            :last last)))     (otherwise       (error 'keyform-not-supported :keyform keyform))))(defmethod word-reference-accessor ((container application) keyForm keyData)  (when (front-window)    (word-reference-accessor (front-window) keyForm keyData)))(defun buffer-word-start (buffer &optional (start 0) (count 0))  "Returns the position of the start of the word at position in buffer-mark. count maybe used to find the start of previous (not yet) or subsequent words."  (do ((pos (buffer-forward-find-char buffer *fred-word-constituents* start)            (buffer-forward-find-char buffer *fred-word-constituents*              (or (and pos (buffer-word-end buffer pos 0)) (buffer-size buffer)))))      ((zerop count) (when pos (1- pos)))    (decf count)))(defun buffer-word-end (buffer &optional (start 0) (count 0))  (do ((pos (buffer-forward-find-not-char buffer *fred-word-constituents* start)            (buffer-forward-find-not-char buffer *fred-word-constituents*              (or (and pos (buffer-word-start buffer pos 0)) (buffer-size buffer)))))      ((zerop count) (cond (pos (1- pos))((zerop count) (buffer-size buffer))))    (decf count)))(defmethod character-range ((reference word-reference))  (with-slots (first last) reference    (let* ((window (content-window reference))           (buffer (fred-buffer window))           (start              (if (numberp first)               (buffer-word-start buffer 0 (1- first))               (insertion-position first :before)))           (end             (when start               (typecase last                 (number                    (buffer-word-end buffer start (- last first)))                 (otherwise                   (insertion-position last :after))))))      (if (and start end)        (values start end)        (error "Reference beyond last word")))))(defmethod insertion-position ((base word-reference) position)   (with-slots (first last container) base     (let* ((window (content-window base))            (buffer (fred-buffer window))            (pos (etypecase position                  (keyword                    (case position                      (:before (buffer-word-start buffer 0 (1- first)))                      (:after (buffer-word-end buffer 0 (1- (or last first))))))                  (number                    (if (plusp position)                      (buffer-word-start buffer 0 (+ first position))                      (buffer-word-end buffer 0 (+ (or last first) position)))))))         (assert pos () "Insertion point out of bounds")         pos)))#|(setf ref  (make-instance 'word-reference    :first 1    :container (target)))(character-range ref)|#;;;;;;;;;;;;;;(provide :ae-text-suite)