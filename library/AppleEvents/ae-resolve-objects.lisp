;;;-*- Mode: Lisp; Package: CCL -*-;;;;;; ae-objects.lisp;;;;;; Resolve Object Specifiers in AppleEvent handlers.;;; Basic support for accessing object properties from scripts.;;;;;; Copyright © 1999-2010 Terje Norderhaug and Media Design in¥Progress;;;;;; Version: 1.0;;;;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as this copyright ;;; notice is left intact in the source code.;;;;;; Digitool is welcome to integrate parts or whole of this module in MCL without;;; including the copyright note, as long as the author is mentioned in the version history.;;;;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;;;;; Author: Terje Norderhaug <terje@in-progress.com> of Media Design in¥Progress.;;;;;; Tested on MCL 4.2, MCL 4.3.1 and 4.3.5 but should also work with other recent versions of MCL.;;; Tested on MCL 5.1 and RMCL 5.2.1.#| HISTORY:2010-Feb-03 Terje Added :upp-creator to resolve-object-specifier-record-handler.2010-Jan-21 Terje Fix set-token-object and token-objet as :aedesc.datahandle is obsolete after MacOSX 10.2                    http://developer.apple.com/qa/qa2001/qa1139.html2010-Jan-21 Terje Ignore defining ostype-to-long for MCL 5.2 and beyond2002-Dec-02 Terje AEGetParamDesc replaces AEGetKeyDesc for carbon compatability.2002-Oct-28 Terje Fixed problem when cheap-free-list+ was called with list eq tail.1999-Oct-13 Terje  0.82a Made %aeresolve-results into a cheap consed property list.1999-Sep-15 Terje  0.81a minor changes to resolve-object-specifier suggested by Steve Hain.1999-Sep-14 Terje  0.80a public released.|##|This module implements support for AppleEvent object accessors. It facilitates resolving object specifiers into LISP objects, so that scripts and applications can specify objects as argument to AppleEvents.After using INSTALL-OBJECT-ACCESSOR to install appropriate object accessors, your application can act on AppleEvents that includes object references, like those that would result from the following AppleScript statements:   set character 1 thru 4 of document "New" to "Test"   set the middle character to "*"   open file "my filename"   close window "new" saving in file "oh my"   if document "abc" is modified then save in file "temp"The object accessors for the statements above are covered by the ae-core-suite module, so you don't have to implement them yourself. However, you can use the ae-objects module to implement support for other standard suites, or to support a custom suite with events and classes relevant for your own application.An object accessor is a method that finds an object based on a container object and a key. For example, to support AppleScript statements like [delete character 1 of document "New"] you define two object accessors: One that finds a document window based on a namestring, another that finds (or creates) a character reference based on a document window and a character index number. Say that an application has received an AppleEvent for Delete with an object specifier for Character 1 of Document "New", corresponding to the example above. The AppleEvent handler for delete will use RESOLVE-OBJECT-SPECIFIER to resolve the object specifier into a LISP object that represents the first character of the document. The object specifier is resolved into an object by calling the two object accessors.The resulting object can then be used as the first argument to a method that takes action in deleting the character. You may specialize such methods for various types of objects, providing an object oriented and extendable scheme for handling AppleEvents that act on different types of objects.|#;;;; RELATED DOCUMENTATION:;;;; Introduction to Apple Events;;   http://developer.apple.com/techpubs/mac/IAC/IAC-94.html;; Working With Object Specifier Records;;   http://developer.apple.com/techpubs/mac/IAC/IAC-106.html;; Finding Apple Event Objects (***);;   http://developer.apple.com/techpubs/mac/IAC/IAC-109.html;; Resolving and Creating Object Specifier Records;;   http://developer.apple.com/techpubs/mac/IAC/IAC-231.html#| TODO:aedesc.datahandle should no longer be used beyond MacOSX 10.2 (http://developer.apple.com/qa/qa2001/qa1139.html)|#(in-package :ccl)(eval-when (:execute :load-toplevel)  (require :appleevent-toolkit)  (export 'resolve-object-specifier)  (export 'install-object-accessor)  (export 'deinstall-object-accessor)  (export 'define-ae-object-class));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;#-ccl-5.2(eval-when (:compile-toplevel :execute)  (defun ostype-to-long (ostype)    (rlet ((result long))      (%put-ostype result ostype)      (%get-long result))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INSTALLING ENTRIES IN THE OBJECT ACCESSOR DISPATCH TABLES;;;; http://developer.apple.com/techpubs/mac/IAC/IAC-239.html;;;; We bypass the AppleEvent Manager's object accessor dispatch routine.;; It allows us to register standard LISP functions and methods for dispatch ;; rather than having to define all as pascal functions.;; This follows the implementation in l1-highlevel-event of MCL.;;;; AEResolve spec:;;   http://developer.apple.com/techpubs/mac/IAC/IAC-267.html(defun resolve-object-specifier (object-specifier-record)  "Resolves an object specifier into a LISP object"  (declare (special %aeresolve-results))  (let* ((%aeresolve-results (when (boundp '%aeresolve-results) %aeresolve-results))         (old %aeresolve-results))    (declare (special %aeresolve-results))    (unwind-protect      (with-aedescs (token)        (ae-error-str "Failed to resolve object specifier record"           (#_AEResolve object-specifier-record             (+ #$kAEIDoWhose #$kAEIDoMarking #$kAEHandleSimpleRanges)             token))        (token-object token))      (cheap-free-list+ %aeresolve-results old))));; Candidate to supersede the current cheap-free-list in MCL:(defun cheap-free-list+ (list &optional tail)  "Free the conses in the list until the optional tail"  (unless (eq list tail)    (let ((l list)          next-l)      (loop        (setq next-l (cdr l))        (free-cons l)        (when (or (atom (setq l next-l))                  (eq l tail))          (return))))))(defconstant $ae-result-descriptortype :|AEre| "Internal descriptor type for LISP results from an AE resolver")(defmethod set-token-object (token object)  (declare (special %aeresolve-results))  (let* ((key (if %aeresolve-results (1+ (car %aeresolve-results)) 1)))    (rlet ((ptr :long key))      (ae-error (#_AEReplaceDescData $ae-result-descriptortype ptr #.(record-field-length :long) token)))    (setf %aeresolve-results      (cheap-cons key        (cheap-cons object %aeresolve-results)))    token))(defun token-object (token)  (declare (special %aeresolve-results))  (when token     (rlet ((&ptr :long))       (#_AEGetDescData token &ptr #.(record-field-length :long))       (let ((key (pref &ptr :long)))         (getf %aeresolve-results key)))))(defvar %object-specifier-record-handlers% (make-hash-table :test #'eq :size 4))(defun install-object-accessor (class type function &optional refcon)  (flet ((normalize (desctype)           (case desctype             ((NIL) #$typeNull)             ((T) #$typeWildCard)             (otherwise desctype))))    (let* ((class (normalize class))           (type (normalize type))           (id-table (gethash class %object-specifier-record-handlers%)))      (unless id-table        (setq id-table (make-hash-table :test #'eq :size 1))        (setf (gethash class %object-specifier-record-handlers%) id-table))      (if function        (setf (gethash type id-table)           (if refcon            (list function refcon)            (list function)))        (progn          (remhash type id-table)          (when (= 0 (hash-table-size id-table))            (remhash class %object-specifier-record-handlers%)))))))(defun deinstall-object-accessor (class type)  (install-object-accessor class type NIL))(defun find-object-accessor (class type)  (flet ((lookup (id id-table)           (and id-table               (or (gethash id id-table)                   (gethash #$typeWildCard id-table)))))     (or (lookup type            (gethash class %object-specifier-record-handlers%))         (lookup type           (gethash #$typeWildCard %object-specifier-record-handlers%)))))(defun intern-keyform (keyForm)  (case keyForm    (#.(ostype-to-long #$formPropertyID) :property-id)    (#.(ostype-to-long #$formName) :name)    (#.(ostype-to-long #$formUniqueID) :unique-id)    (#.(ostype-to-long #$formAbsolutePosition) :absolute-position)    (#.(ostype-to-long #$formRelativePosition) :relative-position)    (#.(ostype-to-long #$formTest) :test)    (#.(ostype-to-long #$formWhose) :whose)    (#.(ostype-to-long #$formRange) :range)    (otherwise      (rlet ((ptr :ostype keyForm))        (%get-ostype ptr)))))(defpascal resolve-object-specifier-record-handler    (:long desiredClass       ; DescType;      :ptr containerToken      ; AEDesc;      :long containerClass     ; DescType;     :long keyForm            ; DescType;      :ptr keyData             ; AEDesc;     :ptr Token               ; AEDesc      :long refcon     :upp-creator #_NewOSLAccessorUPP      :word)  (declare (ignore refcon))  ; (declare (inline find-object-accessor))  (rlet ((class-ptr :ostype containerClass)         (desired-ptr :ostype desiredClass))      (let* ((desired (%get-ostype desired-ptr))           (class (%get-ostype class-ptr))           (form-type (intern-keyform keyForm))           (handler (or (find-object-accessor desired class)                        (error (make-condition 'appleevent-error                                   :oserr #$errAEAccessorNotFound                                  :error-string (format nil "No Object Accessor for '~a' '~a'"                                           desired class)))))           (container (if (eq (pref containerToken :aedesc.descriptortype) #$typeNull)                        *application*                        (token-object containerToken))))      (handler-case        (set-token-object token          (apply (car handler) container form-type keyData (cdr handler)))        (appleevent-error (condition)          (signal condition))        (error (condition)          (if (method-exists-p (car handler) container form-type keyData (cdr handler))            (signal condition)            (signal 'appleevent-error                :oserr #$errAEEventNotHandled               :error-string (format NIL "~A" condition)))))  #$noErr)))(defvar *object-accessors-p* NIL "True if the MacOS supports AE object accessors")(def-ccl-pointers object-accessor-events ()  (when (gestalt #$gestaltAppleEventsAttr #$gestaltAppleEventsPresent)    (ecase (#_AEObjectInit)      (#.#$noErr (setf *object-accessors-p* T))      (#.#$memFullErr (error "Not enough memory for object accessors"))      (#.#$errAENewerVersion (warn "Object Accessors needs a newer version of the Apple Event Manager")))    (#_AEInstallObjectAccessor #$typeWildCard #$typeWildCard        resolve-object-specifier-record-handler 0 nil)))#| An object accessor function listed in the system dispatch table must reside in the system heap; thus, if the value of the isSysHandler parameter is TRUE, the theAccessor parameter should point to a location in the system heap. Otherwise, if you put your system object accessor function in your application heap, you must call AERemoveObjectAccessor to remove the function before your application terminates. <http://gemma.apple.com/techpubs/mac/IAC/IAC-260.html#MARKER-2-309>.|# (eval-when (:load-toplevel :execute)  (push     #'(lambda ()        (when *object-accessors-p*          (#_AERemoveObjectAccessor #$typeWildCard #$typeWildCard             resolve-object-specifier-record-handler NIL)))    *lisp-cleanup-functions*))(define-condition keyform-not-supported (appleevent-error)  ((keyform :initarg :keyform :initform NIL)   (error-string :initform "Keyform not supported")   (oserr :initform #$ERRAEBADKEYFORM))) ;; ## should use another constant!!;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ACCESS VALUES IN AEDESCS(defun ae-put-parameter-boolean (the-desc keyword value &optional (errorp t))  ; ## perhaps Digitool should add this with the other ae-put functions?  (rlet ((buffer :boolean))    (%put-word buffer (if value -1 0))    (ae-errorp-handler      errorp      (ae-error (#_AEPutParamPtr the-desc keyword #$typeBoolean buffer                 (record-length :boolean))))));;; ## These might be moved to a separate module for value accessors:(defgeneric ae-get-parameter-as (type key event &optional errorp)  (:documentation "Get a parameter for the key with the desired type"))(defmethod ae-get-parameter-as (type keyword event &optional (errorp t))  (declare (ignore type keyword event errorp))  NIL)(defmethod ae-get-parameter-as ((desired-type (eql #$typeEnumerated)) keyword event &optional (errorp t))  (declare (ignore errorp))  (%stack-block ((type-ptr 4)                 (size-ptr 4))    (when (eql #$noErr (#_AESizeOfParam event keyword type-ptr size-ptr))      (let ((type (%get-ostype type-ptr))            (size (%get-unsigned-long size-ptr)))       (unless (or (eql size 0)(eql type #$typeNull))         (%stack-block ((data size)                        (actual-type 4)                        (actual-size 4))           (ae-error (#_AEGetParamPtr event keyword desired-type actual-type data size actual-size))           (%get-ostype data)))))))(defmethod ae-get-parameter-as ((desired-type (eql #$typeText)) keyword event &optional (errorp t))  (ae-get-parameter-char event keyword errorp))(defmethod ae-get-parameter-as ((desired-type (eql #$typeType)) keyword event &optional (errorp t))  (ae-get-parameter-type event keyword errorp))(defmethod ae-get-parameter-as ((desired-type (eql #$typeObjectSpecifier)) keyword event &optional (errorp t))  (declare (ignore errorp))  (with-aedescs (reference)     (#_aegetparamdesc event keyword #$typeObjectSpecifier reference)    (resolve-object-specifier reference)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PROPERTY ACCESSORS(defgeneric set-property-value (name object data)  (:documentation "Specialize to set value of named propeties of an object"))(defclass property-reference ()  ((container :initarg :container)   (name :initarg :name)))(defmethod property-value ((property-reference property-reference))  "Get the property value specified in the reference"  (with-slots (container name) property-reference    (get-property-value name container)))(defmethod get-property-value (property-name (property-reference property-reference))  (with-slots (container name) property-reference    (get-property-value property-name (get-property-value name container))))(defmethod (setf property-value) (data (property-reference property-reference))  "Set the property value of the reference to the value of data (an aedesc)"  (with-slots (container name) property-reference    (set-property-value name container data)))(defmethod property-accessor (container (keyForm (eql :property-ID)) keyData)  (let* ((label (get-keydata-value :property-id keydata)))    (make-instance 'property-reference      :container container      :name label)))(defmethod property-accessor (container keyForm keyData)  (declare (ignore container keydata))  (error 'keyform-not-supported :keyform keyform))(install-object-accessor #$cProperty T #'property-accessor)(defmethod get-property-event-handler (application event reply refcon)  (declare (ignore application refcon))  (with-aedescs (reference)    (ae-error (#_aegetparamdesc event #$keyDirectObject #$typeObjectSpecifier reference))    (let* ((object (resolve-object-specifier reference))           (value (when object (property-value object))))       (etypecase value         (macptr            value)         (number           (ae-put-parameter-longinteger reply #$keyDirectObject              value))         (string           (ae-put-parameter-char reply #$keyDirectObject             value))         (character           (ae-put-parameter-char reply #$keyDirectObject             value))         (boolean           (ae-put-parameter-boolean reply #$keyDirectObject              value))         (keyword             (ae-put-parameter-type reply #$keyDirectObject              value))))))(install-appleevent-handler #$kAECoreSuite #$kAEGetData #'get-property-event-handler)(defmethod set-property-event-handler (application event reply refcon)  (declare (ignore application refcon reply))  (with-aedescs (specifier data)    (ae-error (#_aegetparamdesc event #$keyDirectObject #$typeObjectSpecifier specifier))    (ae-error (#_aegetparamdesc event #$keyAEData #$typeWildCard data))    (let ((reference (resolve-object-specifier specifier)))      (setf (property-value reference) data))))(install-appleevent-handler #$kAECoreSuite #$kAESetData  #'set-property-event-handler);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; KEY DATA ;;;;;; http://developer.apple.com/techpubs/mac/IAC/IAC-233.html;;; Descriptor records;;;     http://developer.apple.com/techpubs/mac/IAC/IAC-98.html;;; List of valid descriptortypes;;;     http://developer.apple.com/techpubs/mac/IAC/IAC-132.html;;; http://developer.apple.com/techpubs/mac/IAC/IAC-237.html;;; http://developer.apple.com/techpubs/mac/IAC/IAC-238.html;;; http://www.devworld.apple.com/dev/techsupport/develop/issue28/reuter.html;;;;;; Get the LISP value of various key data aedescs.(defgeneric get-keydata-value (keyform keydata)  (:documentation "Extract the keydata value given the keyform"))(defmethod get-keydata-value ((keyform (eql :property-id)) keydata)  ; type is #$typeType => ostype  ; consider checking that result is of the correct type for the keyform  (ae-get-desc-data keydata))(defmethod get-keydata-value ((keyform (eql :name)) keydata)  (ecase (pref keydata :aedesc.descriptortype)    (#.#$typeChar      (let ((handle (pref keydata :aedesc.datahandle)))        (with-dereferenced-handles ((ptr handle))           (%str-from-ptr-in-script ptr (#_GetHandleSize handle)))))))(defmethod get-keydata-value ((keyform (eql :absolute-position)) keydata)  ; type is #$typeLongInteger or #$typeAbsoluteOrdinal  ; consider checking that result is of the correct type for the keyform  (ae-get-desc-data keydata))(defmethod get-keydata-value ((keyform (eql :relative-position)) keydata)  ; type is #.#$typeEnumerated with #$kAENext or #$kAEPrevious  ; consider checking that result is of the correct type for the keyform  (ae-get-desc-data keydata))(defmethod get-keydata-value ((keyform (eql :name)) keydata)  ; type is #$typeChar => string  ; consider checking that result is of the correct type for the keyform  (ae-get-desc-data keydata))(defmethod get-keydata-value ((keyform (eql :range)) keydata)  "A value list of the first and last object in the range"  (ecase (pref keydata :aedesc.descriptortype)    (#.#$typeRangeDescriptor      (with-aedescs (range ospec1 ospec2)        (ae-error (#_AECoerceDesc keydata #$typeAERecord range))        (ae-error (#+carbon-compat #_AEGetParamDesc #-carbon-compat #_AEGetKeyDesc                    range #$keyAERangeStart #$typeWildCard ospec1))        (ae-error (#+carbon-compat #_AEGetParamDesc #-carbon-compat #_AEGetKeyDesc                   range #$keyAERangeStop #$typeWildCard ospec2))        (values           (resolve-object-specifier ospec1)          (resolve-object-specifier ospec2))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEFINING OBJECT CLASSES;; This macro should be extended to cover properties etc for the object classes.(defmacro define-ae-object-class (name super &rest args)  (declare (ignore super name))  (let ((ostype (second (assoc :ostype args)))        (accessor (second (assoc :accessor args))))   `(eval-when (:load-toplevel :execute)       ,(when accessor          `(defgeneric ,accessor (container keyForm keyData)))       ,(when (and ostype accessor)          `(install-object-accessor ,ostype T #',accessor)))));;;;;;;;;;;;;;;;; -----(provide :ae-resolve-objects)