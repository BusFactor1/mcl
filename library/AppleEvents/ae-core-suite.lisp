;;;-*- Mode: Lisp; Package: CCL -*-;;;;;; ae-core-suite.lisp;;;;;; Provides basic support for the Core AppleEvents suite by defining all ;;; object classes, propeties and event handlers in the default edition of the suite. ;;; Can be specialized for applications or used as it with MCL.;;;;;; Copyright © 1999-2010 Terje Norderhaug in¥Progress;;;;;; Version: 0.80b;;;;;; Use and copying of this software and preparation of derivative works;;; based upon this software are permitted, so long as this copyright ;;; notice is left intact in the source code.;;;;;; Digitool is welcome to integrate parts or whole of this module in MCL without;;; including the copyright note, as long as the author is mentioned in the version history.;;;;;; This software is made available AS IS, and no warranty is made about ;;; the software or its performance. ;;;;;; Author: Terje Norderhaug <terje@in-progress.com> of in¥Progress.;;;;;; Tested on MCL RMCL 5.2.1 but should also work with other recent versions of MCL.;;;;;;;;; The description of the Core suite is in the AppleScript SDK:;;;    http://developer.apple.com/sdk/#| HISTORY2010-02-03 Terje  Upgraded document-object-accessor on application.2010-02-03 Terje  Upgraded document-object-accessor for window (support e.g "the window after window 3").2010-01-23 Terje  set-property-value justification for windows.2010-01-23 Terje  ae-get-desc-data provides replacement for obsolete :aedesc.datahandle1999-10-17 Terje  0.75a Default core-event-handler for application passes request on to front window.1999-09-14 terje  0.74a Better support for move and duplicate.1999-09-13 terje  0.73a many changes, upgraded to alpha status.1999-09-16 terje  0.72d Name property for Application now works.1999-09-16 terje  Core event handler for Create Element (make) uses get-ae-parameter.1999-09-15 terje  0.71d content-window method for pathnames.1999-09-15 terje  Add calls to content-window from core-event-handler methods.1999-09-15 terje  Window 1 is frontmost instead of window 0 in document-object-accessor.1999-09-15 terje  Supports relative position for character references, like [before character 1]1999-09-15 terje  Added get-ae-parameter method1999-09-14 terje  0.70d public released.|##| TODO:aedesc.datahandle should no longer be used beyond MacOSX 10.2 (http://developer.apple.com/qa/qa2001/qa1139.html)|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (:execute :load-toplevel)  (require :appleevent-toolkit)  (require :ae-resolve-objects))(in-package :ccl)(defun ae-get-desc-data (aedesc)  "Extract data from an aedesc and return as a LISP value"  ; How does this compare to similar functionality in defappleevents?  ; use to replace accesses of :aedesc.datahandle which should not be used after OSX 10.2  ; http://developer.apple.com/qa/qa2001/qa1139.html  ; see also type&pointer->lisp  (let ((type (pref aedesc :aedesc.descriptortype)))    (macrolet ((extract (data mactype &aux (&value (gensym)) (size (gensym)))                 `(let ((,size (#_AEGetDescDataSize ,data)))                    (rlet ((,&value ,mactype))                      (assert (= ,size ,(record-field-length mactype)))                      (errchk (#_AEGetDescData ,data ,&value ,size))                      (pref ,&value ,mactype)))))      (ecase type        (#.#$typeTrue T)        (#.#$typeFalse NIL)        (#.#$typeType         (extract aedesc :ostype))        (#.#$typeChar         (let ((data-size (#_aegetdescdatasize aedesc)))           (%stack-block ((data-ptr data-size))             (errchk (#_aegetdescdata aedesc data-ptr data-size))             (%str-from-ptr-in-script data-ptr data-size))))        (#.#$typeLongInteger          (extract aedesc :long))        (#.#$typeAbsoluteOrdinal         (ecase (extract aedesc :long)           (#.(ostype-to-long #$kAEFirst) :first)           (#.(ostype-to-long #$kAEMiddle) :middle)           (#.(ostype-to-long #$kAELast) :last)           (#.(ostype-to-long #$kAEAny) :any)           (#.(ostype-to-long #$kAEAll) :all)))        (#.#$typeEnumerated         (ecase (extract aedesc :long)           (#.(ostype-to-long #$kAENext) :next)           (#.(ostype-to-long #$kAEPrevious) :previous)           (#.(ostype-to-long #$kAECentered) :center)           (#.(ostype-to-long #$kAELeftJustified) :left)           (#.(ostype-to-long #$kAERightJustified) :right)           (#.(ostype-to-long #$kAEFullyJustified) :fully)))))));; ####################################################################################;; OBJECT SUPER CLASSES(defclass document-content ()  ((container :initarg :container))  (:documentation "Superclass for representations of the content that belong to a document"))(defmethod content-window ((obj document-content))  "Get the window of the object"  (with-slots (container) obj    (content-window container)))(defmethod content-window ((obj property-reference))  "Get the window of the object"  (with-slots (container) obj    (content-window container)))(defmethod print-object ((this document-content) out)  (with-slots (container) this    (format out "#<~A of ~A>" (type-of this) container)))(defclass document-content-range (document-content)  ((first :initarg :first)   (last :initarg :last :initform NIL)))(defmethod print-object ((this document-content-range) out)  (with-slots (first last container) this    (if (or (eq first last) (null last))      (format out "#<~A ~A of ~A>" (type-of this) first container)      (format out "#<~A ~A thru ~A of ~A>" (type-of this) first last container))))(defmethod property-value ((reference document-content-range))  (multiple-value-bind (start end) (character-range reference)    (buffer-substring (fred-buffer (content-window reference)) start end)))(defmethod property-value ((aedesc macptr))   (ecase (pref aedesc :aedesc.descriptortype)      (#.#$typeObjectSpecifier        (property-value (resolve-object-specifier aedesc)))      (#.#$typeChar         (let ((data-size (#_aegetdescdatasize aedesc)))           (%stack-block ((data-ptr data-size))             (errchk (#_aegetdescdata aedesc data-ptr data-size))             (%str-from-ptr-in-script data-ptr data-size))))))(defmethod (setf property-value) (data (reference document-content-range))  (multiple-value-bind (start end) (character-range reference)    (let* ((window (content-window reference)))      (ed-replace-with-undo (fred-item window) start end         (property-value data)))));;;;;;;;;;;;;;;;;;;;;;; All text classes should have a specialization of either of these, or both.;; If a definition is missing, it will result in an endless recursion. (defgeneric character-range (reference);; ## Should we just rename this to selection-range?  (:documentation "A value list of the buffer insertion positions before and after the text object (same as from selection-range)"))(defgeneric insertion-position (reference relation)  (:documentation "The buffer insertion position before or after the object"))(defmethod character-range (reference)  (values     (insertion-position reference :before)    (insertion-position reference :after)))(defmethod insertion-position (reference relation)    (etypecase relation    (keyword      (multiple-value-bind (start end)        (character-range reference)        (ecase relation          (:before start)          (:after end))))    (number      (let ((reference2 (copy-instance reference)))        (with-slots (first last) reference2          (incf first relation)          (incf last relation)          (insertion-position reference (if (minusp relation) :after :before)))))))(defmethod insertion-position ((reference application) relation)    (insertion-position (front-window) relation));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; APPLICATION;; The application is represented by the built-in Application object.;; Usually references to the Application object is implicit, so this is rarely if ever used.(define-ae-object-class application ()  (:ostype #$cApplication)  (:accessor application-object-accessor))(defmethod content-window ((obj application))  (front-window))(defmethod application-object-accessor (container keyForm keyData)  (declare (ignore keyForm keyData container))  *application*)(defmethod get-property-value ((label (eql #$pClipboard)) (object application))  "Get the clipboard"  (unimplemented))(defmethod set-property-value ((label (eql #$pClipboard)) (object application) data)  "Modify the clipboard"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pIsFrontProcess)) (object application) )  "Is this the frontmost application?"  (unimplemented))(defmethod get-property-value ((label (eql #$pName)) (object application))  "The name of the application"  (or (application-name object) (current-app-name) ""))(defmethod get-property-value ((label (eql #$pName)) (object null))  ;; ## specialization on null might no longer be required?  (get-property-value label *application*)) (defmethod get-property-value ((label (eql #$pSelection)) (object application))  "The current selection"  (make-instance 'selection-object-reference    :container object))(defmethod set-property-value ((label (eql #$pSelection)) (object application) data)  "The current selection"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pVersion)) (object application))  "The version of the application"  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CHARACTER(define-ae-object-class character ()  (:ostype #$cChar)  (:accessor character-object-accessor))(defclass character-reference (document-content-range)  ())(defmethod character-object-accessor (container keyform keydata)  (case keyForm     (:absolute-position       (let ((index (get-keydata-value :absolute-position keydata)))          (make-instance 'character-reference            :container container            :first index            :last index)))     (:range       (multiple-value-bind (first last)         (get-keydata-value :range keydata)         (make-instance 'character-reference           :container container           :first first           :last last)))     (otherwise       (error 'keyform-not-supported :keyform keyform))))(defmethod character-object-accessor ((base character-reference) (keyform (eql :relative-position)) keydata)  (let ((relation (get-keydata-value :relative-position keydata)))    (with-slots (container first last) base      (let ((position (case relation (:previous (1- first))(:next (1+ last)))))        (make-instance 'character-reference          :container container          :first position          :last position)))))(defmethod insertion-position ((base character-reference) relation)  (with-slots (container) base    (let ((index (slot-value base (ecase relation (:before 'first)(:after 'last)))))      (typecase index               (null           (assert (eq relation :after))          (insertion-position base :before))        (document-content-range          (insertion-position index relation))        (otherwise          (multiple-value-bind (start end) (character-range container)            (etypecase index              (number                (if (minusp index)                   (+ index end (if (eq relation :before) 0 1))                  (+ index start (if (eq relation :before) -1 0))))              (keyword                (ecase index                  (:all                     (ecase relation                      (:before start)                      (:after end)))                  (:middle (+ (floor (+ start end) 2)                              (if (eq relation :before) 0 1))))))))))))(defmethod get-property-value ((label (eql #$pColor)) (reference character-reference))  "The RGB color of the character(s)"  (unimplemented))(defmethod set-property-value ((label (eql #$pColor)) (reference character-reference) data)  "The RGB color of the character(s)"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pFont)) (reference character-reference))  "The font of the character(s)"  (unimplemented))(defmethod set-property-value ((label (eql #$pFont)) (reference character-reference) data)  "The font of the character(s)"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pPointSize)) (reference character-reference))  "The size of the character(s)"  (unimplemented))(defmethod set-property-value ((label (eql #$pPointSize)) (reference character-reference) data)  "The size of the character(s)"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pScriptTag)) (reference character-reference))  "The writing code of the character(s)"  (unimplemented))(defmethod get-property-value ((label (eql #$pTextStyles)) (reference character-reference))  "The style of the character(s)"  (unimplemented))(defmethod set-property-value ((label (eql #$pTextStyles)) (reference character-reference) data)  "The style of the character(s)"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pUniformStyles)) (reference character-reference))  "The uniform styles of the character(s)"  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DOCUMENT(define-ae-object-class document ()  (:ostype #$cDocument)  (:accessor document-object-accessor)) (defmethod document-object-accessor ((container application) keyform keydata)  (case keyform     (:name      (flet ((find-window (title &optional (type T))               "Override the built in function, which ignores hidden windows (per mcl 5.1)"               (do-all-windows w                 (when (and (typep w type)                            (equal title (window-title w)))                   (return-from find-window w)))))                  (find-window (get-keydata-value :name keydata))))     (:absolute-position ;; Frontmost window has index 1       (let ((index (get-keydata-value :absolute-position keydata))             (count 1))          (do-all-windows w            (if (= count index)              (return w)              (incf count)))))     (otherwise       (error 'keyform-not-supported :keyform keyform))))#+ignore(defmethod document-object-accessor ((container window) keyform keydata)  (document-object-accessor *application* keyform keydata))(defmethod document-object-accessor ((container window) keyform keydata)  (case keyform    (:relative-position        (let ((relative-position (get-keydata-value :relative-position keydata))             (layer (window-layer container)))         (ecase relative-position           (:next (incf layer))           (:previous (decf layer)))         ;; inefficient but straight forward         (nth layer (windows))))    (otherwise ;; not optimal...     (document-object-accessor *application* keyform keydata))))(defmethod document-object-accessor ((container document-content) keyform keydata)  (declare (ignore keyform keydata))  (content-window container))(defmethod get-property-value ((label (eql #$pIsModified)) (object window))  "Has the document been modified?"  (window-needs-saving-p object));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FILE(define-ae-object-class file ()  (:ostype #$cFile)  (:accessor file-object-accessor)) ;;; Pathnames represent files, as usual.(defmethod content-window ((pathname pathname))  (find (mac-namestring pathname) (windows) :test #'equalp :key #'window-filename))(defmethod file-object-accessor ((container application) (keyform (eql :name)) keydata)  (pathname (get-keydata-value :name keydata)))(defmethod file-object-accessor ((container window) keyform keydata)  (file-object-accessor *application* keyform keydata))(defmethod get-property-value ((label (eql #$pIsStationeryPad)) (file pathname))  "Is the file is stationery?"  (unimplemented))(defmethod set-property-value ((label (eql #$pIsStationeryPad)) (file pathname) data)  "Is the file is stationery?"  (declare (ignore data))  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SELECTION OBJECT(define-ae-object-class selection ()) (defclass selection-object-reference (document-content)  ())(defmethod get-property-value ((label (eql #$pContents))(reference selection-object-reference))  "The contents of the selection"  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TEXT(define-ae-object-class text ()  (:ostype #$cText)  (:accessor text-object-accessor)) (defclass text-reference (document-content-range)  ())(defmethod text-object-accessor (container keyform keydata)  (case keyForm     (:range       (multiple-value-bind (first last)         (get-keydata-value :range keydata)         (make-instance 'text-reference           :container container           :first first           :last last)))     (:name        (get-keydata-value :name keydata))      (otherwise       (error 'keyform-not-supported :keyform keyform))))(defmethod get-property-value ((label (eql #$pFont))(reference text-reference))  "The font of the first character"  (with-slots (first) reference    (get-property-value #$pFont first)))(defmethod set-property-value ((label (eql #$pFont)) (reference text-reference) data)  "The font of the first character"  (declare (ignore data))  (unimplemented))(defmethod property-value ((reference text-reference))  "The text string"  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TEXT STYLE INFO(define-ae-object-class text-style-info ()) (defclass text-style-info-reference (document-content)  ());;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; WINDOW(define-ae-object-class window ()  (:ostype #$cWindow)  (:accessor window-object-accessor))(defmethod content-window ((obj window))  obj) (defmethod window-object-accessor (container keyform keydata)  (document-object-accessor container keyform keydata))(defmethod character-range ((window window))  (values 0 (buffer-size (fred-buffer window))))(defmethod get-property-value ((label (eql #$pName)) (object window))  (window-title object))(defmethod get-property-value ((label (eql #$pBounds))(window window))  "The boundaries of the window (rect)"  (unimplemented))(defmethod set-property-value ((label (eql #$pBounds))(window window) data)  "The boundaries of the window"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pHasCloseBox))(window window))  "Does the window have a close box?"  (unimplemented))(defmethod get-property-value ((label (eql #$pHasTitleBar))(window window))  "Is the widnow titled?"  (neq (window-title window) ""))(defmethod get-property-value ((label (eql #$pIndex))(window window))  "The index number of the window"  (1+ (window-layer window)))(defmethod set-property-value ((label (eql #$pIndex))(window window) data)  "The index number of the window"  (set-window-layer window    (1- (ae-get-desc-data data))))(defmethod get-property-value ((label (eql #$pIsFloating))(window window))  "Is the window floating?"  (typep window 'windoid))(defmethod get-property-value ((label (eql #$pIsModal))(window window))  "Is the window modal?"  (eq window (caar *modal-dialog-on-top*)))(defmethod get-property-value ((label (eql #$pIsResizable))(window window))  "Is the window resizable?"  (unimplemented))(defmethod get-property-value ((label (eql #$pIsZoomable))(window window))  "Is the window zoomable?"  (unimplemented))(defmethod get-property-value ((label (eql #$pIsZoomed))(window window))  "Is the window zoomed?"  (unimplemented))(defmethod set-property-value ((label (eql #$pIsZoomed))(window window) data)  "Is the window zoomed?"  (declare (ignore data))  (unimplemented))(defmethod get-property-value ((label (eql #$pVisible))(window window))  "Is the window visible?"  (window-shown-p window))(defmethod set-property-value ((label (eql #$pVisible))(window window) data)  "Hide or show a window"  (if (ae-get-desc-data data)    (window-show window)    (window-hide window)));; Content property is not in default dictionary, but frequently used on windows anyway:(defmethod set-property-value ((label (eql #$pContents))(window window) data)  "Replace the contents of the window"  (let* ((buffer (fred-buffer window))         (datahandle (rref data aedesc.datahandle))         (string (with-dereferenced-handles ((ptr datahandle))                  (%str-from-ptr-in-script ptr (#_GetHandleSize datahandle)))))    (ed-replace-with-undo (fred-item window) 0 (buffer-size buffer) string)    (fred-update window)))(defmethod set-property-value ((label (eql #$pContents))(app application) data)  (set-property-value label (front-window) data))(defmethod get-property-value ((label (eql #$pContents))(window window))  (buffer-substring (fred-buffer window) 0 (buffer-size (fred-buffer window))))(defmethod get-property-value ((label (eql #$pContents))(app application) )  (get-property-value label app))(defmethod set-property-value ((label (eql #$pJustification)) (object window) aedesc)  (let ((justification (ae-get-desc-data aedesc)))    (setf (fred-justification object)      (ecase justification        (:left :left)        (:right :right)        (:full :center)        (:center :center)))    (fred-update object)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INSERTION POINT(define-ae-object-class insertion-point ()  (:ostype #$cInsertionPoint)  (:accessor insertion-point-object-accessor)) (defclass insertion-point-reference ()  ((base :initarg :base)   (position :initarg :position)))(defmethod content-window ((reference insertion-point-reference))  (content-window (slot-value reference 'base)))(defmethod print-object ((reference insertion-point-reference) out)  (with-slots (base position) reference    (format out "#<INSERTION-POINT ~A ~A>" position base)))(defmethod insertion-point-object-accessor (container (keyForm (eql :relative-position)) keydata)  (let ((position (ecase (get-keydata-value :relative-position keydata)                     (:next :after)                     (:previous :before))))    (make-instance 'insertion-point-reference      :base container      :position position)))(defmethod character-range ((reference insertion-point-reference))  (with-slots (base position) reference    (let ((index (insertion-position base position)))      (values index index))))(defmethod insertion-position ((reference property-reference) position)  "Insertion point relative to the selection"  (with-slots (container name) reference    (assert (eq name :|sele|) () "Cannot have an insertion point relative to ~A" name)    (multiple-value-bind (start end)      (selection-range (content-window container))      (ecase position        (:before start)        (:after end)))))(defmethod (setf property-value) (data (reference insertion-point-reference))  (let ((window (content-window reference)))    (ed-insert-with-undo (fred-item window)      (property-value data)      (character-range reference))    (fred-update window)));; ################################################################################;; EVENT HANDLERS(defmethod application-core-event-handler (application event reply refcon)  (declare (ignore application refcon))  (let* ((command (ae-get-attribute-type event #$keyEventIDAttr))         (object (or (get-ae-parameter #$keyDirectObject event) *application*)))    (core-event-handler object command event reply)))(install-appleevent-handler #$kAECoreSuite #$typeWildCard  #'application-core-event-handler)(defmethod get-ae-parameter (key event &optional (errorp T))  "Get a parameter from an event as a LISP object"  (with-aedescs (reference)    (#_aegetparamdesc event key #$typeWildcard reference)    (case (pref reference :aedesc.descriptortype)      (#.#$typeNull NIL)      (#.#$typeLongInteger        (ae-get-parameter-longinteger event key errorp))      (#.#$typeText        (ae-get-parameter-char event key errorp))       (#.#$typeObjectSpecifier         (resolve-object-specifier reference))      (#.#$typeEnumerated        (ae-get-parameter-as #$typeEnumerated key event errorp))      (#.#$typeType        (ae-get-parameter-type event key errorp))      (#.#$typeInsertionLoc        (with-aedescs (desc)          (#_AECoerceDesc reference #$typeAERecord desc)          (let ((base (ae-get-parameter-as #$typeObjectSpecifier #$keyAEObject desc errorp))                (pos (ecase (ae-get-parameter-as #$typeEnumerated #$keyAEPosition desc errorp)                        (#.#$kAEAfter :after)                        (#.#$kAEBefore :before))))            (make-instance 'insertion-point-reference              :base base              :position pos)))))))(defmethod core-event-handler (object command event reply)  (error 'appleevent-error      :oserr #$errAEEventNotHandled     :error-string (format NIL "No core event handler for '~A' on ~A" (string command) (type-of object))))(defmethod core-event-handler ((object application) command event reply)  (let ((window (front-window)))    (if (method-exists-p #'core-event-handler window command event reply)      (core-event-handler (front-window) command event reply)      (call-next-method))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CLASS INFO(defmethod core-event-handler ((window window) (command (eql #$kAEGetClassInfo)) event reply)  (declare (ignore event reply))  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CLOSE(defmethod core-event-handler ((window window) (command (eql #$kAEClose)) event reply)  (declare (ignore reply))   (let* ((destination            (or (ae-get-parameter-as #$typeText #$keyAEFile event NIL)               (ae-get-parameter-as #$typeObjectSpecifier #$keyAEFile event nil)))         (saving            (or (ae-get-parameter-as #$typeEnumerated #$keyAESaveOptions event NIL)               (if destination #$kAEYes #$kAEAsk))))             (when (or (window-needs-saving-p window) destination)      (ecase saving        (#.#$kAENo)        (#.#$kAEYes          (when destination            (set-window-filename window destination))          (window-save window ))        (#.#$kAEAsk          (when (window-ask-save window)            (window-save window)))))    (window-close window)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COUNT(defmethod core-event-handler (object (command (eql #$kAECountElements)) event reply)  (let ((class (or (ae-get-parameter-as #$typeType #$keyAEObjectClass event NIL) #$cChar)))    (ae-put-parameter-longinteger reply #$keyDirectObject      (ae-count object class))));(defmethod core-event-handler ((target application) (command (eql #$kAECountElements)) event reply);  (when (front-window);    (core-event-handler (front-window) command event reply)))(defmethod ae-count ((reference window) (type (eql #.#$cChar)))  (buffer-size (fred-buffer reference)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATA SIZE(defmethod core-event-handler (object (command (eql #$kAEGetDataSize)) event reply)  (declare (ignore object event reply))  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DELETE(defmethod core-event-handler ((reference document-content-range) (command (eql #$kAEDelete)) event reply)  (declare (ignore event reply))  (multiple-value-bind (start end) (character-range reference)    (let ((window (content-window reference)))      (ed-delete-with-undo (fred-item window) start end)      (fred-update window))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DUPLICATE(defmethod core-event-handler ((reference document-content-range) (command (eql #$kAEClone)) event reply)  (declare (ignore reply))  (let ((target (get-ae-parameter #$keyAEInsertHere event)))    (ae-clone reference target)))(defgeneric ae-clone (object target)  (:documentation "Duplicates the object from its current location to the target location"))(defmethod ae-clone ((reference document-content-range) target)  (let* ((source (fred-item (content-window reference)))         (destination (if target (fred-item (content-window target)) source)))    (multiple-value-bind (start1 end1)       (character-range reference)      (let ((string (buffer-substring (fred-buffer source) start1 end1)))        (if target          (multiple-value-bind (start2 end2)            (character-range target)            (ed-replace-with-undo destination start2 end2 string))          (ed-insert-with-undo destination string end1))               (fred-update destination)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; EXISTS(defmethod core-event-handler (object (command (eql #$kAEDoObjectsExist)) event reply)  (declare (ignore event))  (ae-put-parameter-boolean reply #$keyDirectObject object))(defmethod core-event-handler ((object application) (command (eql #$kAEDoObjectsExist)) event reply)  (ae-put-parameter-boolean reply #$keyDirectObject NIL))(defmethod core-event-handler ((reference document-content-range) (command (eql #$kAEDoObjectsExist)) event reply)  (declare (ignore event))  (multiple-value-bind (start) (character-range reference)    (let ((buffer (fred-buffer (content-window reference))))      (ae-put-parameter-boolean reply #$keyDirectObject        (<= start (buffer-size buffer))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GET EVENT INFO(defmethod core-event-handler (object (command (eql #$kAEGetEventInfo)) event reply)  (declare (ignore object event reply))  (unimplemented));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; MAKE(defmethod core-event-handler ((object application) (command (eql #$kAECreateElement)) event reply)  (declare (ignore reply))  (let ((class-name            (ae-get-parameter-as #$typeType #$keyAEObjectClass event))        (location-reference           (get-ae-parameter #$keyAEInsertHere event))        (data            (ae-get-parameter-char event #$keyAEData NIL)))    (make-ae-object class-name location-reference data)))(defmethod make-ae-object ((class-name keyword) location-reference data &optional properties)  ;; ## perhaps propeties should be key arguments?  (declare (ignore location-reference data properties))  (unimplemented))(defmethod make-ae-object ((class-name (eql #$cWindow)) location-reference data &optional properties)  (declare (ignore data properties))  (let ((window (make-instance 'window)))    (when (numberp location-reference)      (set-window-layer window location-reference))))(defmethod make-ae-object ((class-name (eql #$cDocument)) location-reference data &optional properties)  (declare (ignore location-reference data properties))  (fred));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; MOVE(defmethod core-event-handler (object (command (eql #$kAEMove)) event reply)  (declare (ignore reply))  (let ((target (get-ae-parameter #$keyAEInsertHere event)))    (ae-move object target)))(defgeneric ae-move (object target)  (:documentation "Move the object from its current location to the target location"))(defmethod ae-move ((object-reference document-content-range) target)  (let ((source (fred-item (content-window object-reference)))        (destination (fred-item (content-window target))))    (multiple-value-bind (start1 end1)       (character-range object-reference)      (multiple-value-bind (start2 end2)        (character-range target)        (when (eq source destination) ;; ensure that selection doesn't get messed up          (setf start2 (make-mark (fred-buffer source) start2))           (setf end2   (make-mark (fred-buffer source) end2)))        (let ((string (buffer-substring (fred-buffer source) start1 end1)))          (ed-delete-with-undo source start1 start1)            (ed-replace-with-undo destination start2 end2 string T)          (fred-update source)          (unless (eq source destination)            (fred-update destination)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; OPEN(defmethod core-event-handler ((app application) (command (eql #$kAEOpen)) event reply)  (open-documents-handler app event reply 0)) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; PRINT(defmethod core-event-handler (object (command (eql #$kAEPrint)) event reply)  (declare (ignore object))  (print-documents-handler *application* event reply 0));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; QUIT(defmethod core-event-handler (object (command (eql #$kAEQuitAll)) event reply)  (declare (ignore object))  (quit-application-handler *application* event reply 0));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SAVE(defmethod core-event-handler (object (command (eql #$kAESave)) event reply)  (declare (ignore event reply))  (window-save (content-window object)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SUITE INFO(defmethod core-event-handler ((window window)(command (eql #$kAEGetSuiteInfo)) event reply)  (declare (ignore event reply))  (unimplemented));;;;;;;;;;;;;;;;;;;;(provide :ae-core-suite)         