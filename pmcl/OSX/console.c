#ifdef CONSOLE/* *  console.c * *  Copyright (c) 1991-1995 Symantec Corporation.  All rights reserved. * * $Header: /home/gtbyers/cvs/MCL-dev/pmcl/console.c,v 1.1.1.1 2002/11/18 03:12:57 gtbyers Exp $ *//* *  and :/*  Copyright.: ©Copyright 1993 by metrowerks inc. All rights reserved. *//*  02/18/00 akh  fixed validrect and invalrect for CARBON - also did all the accessor_calls_are_functions stuff I think.  08/05/96 bill  Gary's fix to what he uploaded in d19  07/26/96  gb   changed everything.  ----- 3.9  12/09/95  gb   console_read returns bizarre result that MPW expects;                 pragmas, detabify.*//* Where there used to be one structure, consoleTextWindow, containing an included windowrecord plus  other info, now consoleTextWindow just contains the other info because it doesn't work now  to glom the windowrecord contents into a structure (i.e. NewWindow pukes when given a first arg other than  null-ptr aka 0L). Consolewindow (lowercase c) is a new  variable containing a pointer to the windowrecord who is a friend of consoleTextWindow.    Sort of works now, but saving to file doesn't work, closing window doesn't work, reselecting consolewindow doesn't work,  copy and paste don't work. Non CARBON case is probably broken.  Other than all that ... at least you get to see the message.  */#include <Printing.h>#include <Menus.h>#include <Memory.h>#include <Fonts.h>#include <Events.h>#include <Menus.h>#include <Devices.h>#include <ToolUtils.h>#include <Devices.h>#include <Errors.h>#include <Scrap.h>#include <Processes.h>#include <Events.h>#include <EPPC.h>#include <Files.h>#include <Controls.h>#include <TextEdit.h>#include <StandardFile.h>#include <LowMem.h>#include <traps.h>#define LMGetWWExist() (*(char *)0x8F2)#include <stdio.h>#include <stddef.h>#include <stdlib.h>#include <string.h>#include <signal.h>#include <errno.h>#include "console.h"Handle savemenubar, consolemenubar;MenuHandle appleMenu, fileMenu, editMenu;short           consoleselstart =             /*  The starting point for a read (can't read before this) ... */                    0;Rect            consoleDragRect =             /*  The global drag rect ... */                    {100, 100, 32000, 32000};Rect            consoleBigRect =              /*  The global clip rect ... */                    {-32000, -32000, 32000, 32000};Boolean         consoleQuitting =             /*  Are we quitting? ... */                    false;Boolean         consoleUseWaitNextEvent =     /*  Can we use WaitNextEvent? ... */                    false;tconsoleSettings  consoleSettings =             /*  User customizable console settings ... */{  false,                        /* ToolBox should already be initialized */  false,                        /* Not running standalone */  true,                         /* Install console menus */  false,                        /* auto-close on quit */  true,                         /* ask to save on close */  false,                        /* show status line */  8,                            /* Tab size */  80,                           /* num columns */  24,                           /* num rows */  0,                            /* top pixel  */  0,                            /* leftmost pixel */  kFontIDMonaco,                       /* font */  9,                            /* size */  normal                        /* face */};tconsoleState     consoleState =                /*  Used to signal that we are trying to get a string ... */                    OFF;pconsoleWin       consoleTextWindow;            /*  Pointer to the console text window structure ... */WindowPtr consolewindow;static int open_console_driver(void);static int doClose(void);static int doControl( CntrlParam *pb, DCtlPtr dce );static int console_refnum = 0;static int console_seq = 0;static Boolean console_menubar_installed = false;enum {  uppdoControlInfo = kRegisterBased | REGISTER_ROUTINE_PARAMETER(1,kRegisterA0,kFourByteCode)| \    REGISTER_ROUTINE_PARAMETER(2,kRegisterA1,kFourByteCode),    uppdoCloseInfo = kPascalStackBased};typedef UniversalProcPtr doControlUPP;typedef UniversalProcPtr doCloseUPP;#ifndef CARBON#define NewdoControlProc(userRoutine)  \  (doControlUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppdoControlInfo, GetCurrentISA())#define NewdoCloseProc(userRoutine)  \  (doCloseUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppdoCloseInfo, GetCurrentISA())#endif#pragma options align=mac68kstruct vector {  short   vJMP;  union {    doControlUPP vdoControl;    doCloseUPP vdoClose;  } upp;};#define OFS(x)  offsetof(struct Drvr, x)static struct Drvr {  short drvrFlags, drvrDelay, drvrEMask, drvrMenu;  short drvrOpen, drvrPrime, drvrCtl, drvrStatus, drvrClose;  char drvrName[10];  short drvrRTS;  struct vector vCtl, vClose;} drvr = {  (dCtlEnableMask| dRAMBasedMask| dOpenedMask),  0,   ((1<<nullEvent) | (1<<mouseDown) | (1<<keyDown) | (1<<updateEvt) | (1<<activateEvt)),  0,  OFS(drvrRTS), OFS(drvrRTS), OFS(vCtl), OFS(drvrRTS), OFS(vClose),  "\p.console",  0x4E75,  { 0x4EF9 }, { 0x4EF9 }}, **drvrH;#pragma options align=resetHandleuse_menubar(Handle newmenubar){  Handle in_use = GetMenuBar();    if (in_use == newmenubar) {    return (Handle) NULL;  }  if (newmenubar != (Handle)NULL) {    SetMenuBar(newmenubar);    DrawMenuBar();  }  return in_use;}void consoleUpdateMenuItems(void){#ifndef CARBON  /*	First disable all possible items ...  DisableMenuItem won't link with interfaceLib today */  DisableItem(fileMenu, FILESAVE);  DisableItem(fileMenu, FILEPRINT);  DisableItem(fileMenu, FILEPAGESETUP);  DisableItem(editMenu, EDITCUT);  DisableItem(editMenu, EDITCOPY);  DisableItem(editMenu, EDITPASTE);  DisableItem(editMenu, EDITCLEAR);  DisableItem(editMenu, EDITSELECTALL);  if (consoleState != PRINTFING && consoleIsAppWindow(FrontWindow())) {    EnableItem(editMenu, EDITPASTE);    EnableItem(editMenu, EDITSELECTALL);        if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableItem(editMenu, EDITCUT);    }    if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableItem(editMenu, EDITCOPY);    }    if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableItem(editMenu, EDITCLEAR);    }    if (consoleTextWindow->dirty) {      EnableItem(fileMenu, FILESAVE);    }  }#else/*	First disable all possible items ...  DisableMenuItem won't link with interfaceLib today */  DisableMenuItem(fileMenu, FILESAVE);  DisableMenuItem(fileMenu, FILEPRINT);  DisableMenuItem(fileMenu, FILEPAGESETUP);  DisableMenuItem(editMenu, EDITCUT);  DisableMenuItem(editMenu, EDITCOPY);  DisableMenuItem(editMenu, EDITPASTE);  DisableMenuItem(editMenu, EDITCLEAR);  DisableMenuItem(editMenu, EDITSELECTALL);  if (consoleState != PRINTFING && consoleIsAppWindow(FrontWindow())) {    EnableMenuItem(editMenu, EDITPASTE);    EnableMenuItem(editMenu, EDITSELECTALL);        if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableMenuItem(editMenu, EDITCUT);    }    if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableMenuItem(editMenu, EDITCOPY);    }    if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {      EnableMenuItem(editMenu, EDITCLEAR);    }    if (consoleTextWindow->dirty) {      EnableMenuItem(fileMenu, FILESAVE);    }  }#endif}void consoleDoMenuChoice(long menuValue){  short   theMenu         = HiWord(menuValue);  short   theMenuItem     = LoWord(menuValue);  if (!consoleIsAppWindow(FrontWindow()))    return;  switch(theMenu) {  case FILEID:    switch (theMenuItem) {    case FILESAVE:      consoleDoSaveText();      break;    default:      break;    }    break;  case EDITID:    switch (theMenuItem) {    case EDITCUT:      consoleDoEditCut();      break;    case EDITCOPY:      consoleDoEditCopy();      break;    case EDITPASTE:      consoleDoEditPaste();      break;    case EDITCLEAR:      consoleDoEditClear();      break;    case EDITSELECTALL:      consoleDoEditSelectAll();      break;    default:      break;    }    break;  default:    break;  }  if (consoleSettings.standalone)    HiliteMenu(0);}/************************************************************************//*  Purpose..:  Determines position on current line (in chars)          *//*  Input....:  TextEdit Handle                                         *//*  Return...:  Position on current line                                *//************************************************************************/static long OffsetOnCurrentLine(TEHandle theTEH){  char *ptr, *start;  long result;  /*  Check for a CR in the buffer ... */  if (consoleBuffer.endpos != consoleBuffer.startpos) {    for (start = consoleBuffer.startpos, ptr = consoleBuffer.endpos; ptr > start; ptr--)      if (*ptr == 0x0d) return (consoleBuffer.endpos - ptr);  }  HLock((Handle)theTEH);  HLock((*theTEH)->hText);  start = *(*theTEH)->hText;  ptr = *(*theTEH)->hText + (*theTEH)->selStart;  while (ptr > start && ptr[-1] != 0x0d)    ptr--;  result = *(*theTEH)->hText + (*theTEH)->selStart - ptr + consoleBuffer.endpos - consoleBuffer.startpos;  HUnlock((*theTEH)->hText);  HUnlock((Handle)theTEH);  return result;}/************************************************************************//*  Purpose..:  Handle a mouseDown event                                *//*  Input....:  pointer to an Event                                     *//*  Return...:  true/false                                              *//************************************************************************/static Boolean HandleMouseDownEvent(EventRecord *theEvent){  WindowPtr window;  short part;  Boolean isconsolewindow;#ifndef CARBON ((WindowPeek)consolewindow)->windowKind = userKind;#else SetWindowKind(consolewindow, userKind);#endif  part = FindWindow(theEvent->where, &window);#ifndef CARBON  ((WindowPeek)consolewindow)->windowKind = console_refnum;#else  SetWindowKind(consolewindow, console_refnum);#endif  isconsolewindow = consoleIsAppWindow(window);  switch (part) {  case inMenuBar:    if (consoleSettings.setupmenus) {      if (console_menubar_installed) {        consoleUpdateMenuItems();        consoleDoMenuChoice(MenuSelect(theEvent->where));        return true;      }    }    break;  case inSysWindow:#ifndef CARBON    if (consoleSettings.standalone)      SystemClick(theEvent, window);#endif    break;  case inContent:    if (isconsolewindow) {      SelectWindow(window);      if (consoleState == PRINTFING) {        if (StillDown())          while (WaitMouseUp())            ;                   /*  Pause output while mouse is down ... */      } else        consoleDoContentClick(window, theEvent);      return true;    }    break;  case inDrag:    if (isconsolewindow) {      DragWindow(window, theEvent->where, &consoleBigRect);      return true;    }    break;  case inGrow:    if (isconsolewindow) {      consoleMyGrowWindow(window, theEvent->where);      return true;    }    break;  case inGoAway:    /* Any time that this event loop is active we wouldn't want the       window to be closed ... */    if (isconsolewindow) {      SysBeep(10);      return true;    }    break;  }  return false;}/************************************************************************//*  Purpose..:  Handle update and activate/deactivate events            *//*  Input....:  pointer to an Event                                     *//*  Return...:  true/false                                              *//************************************************************************/static Boolean HandleUpdateActivateEvent(EventRecord *theEvent){  if (consoleIsAppWindow((WindowPtr)theEvent->message)) {    if (theEvent->what == updateEvt)      consoleUpdateWindow((WindowPtr)theEvent->message);    else {                      /* must be an activate/deactivate event */      if (theEvent->modifiers & activeFlag) {        TEActivate(consoleTextWindow->edit);        ShowControl(consoleTextWindow->vscroll);      } else {        TEDeactivate(consoleTextWindow->edit);        HideControl(consoleTextWindow->vscroll);      }      consoleDrawGrowBox((WindowPtr)consolewindow);      consoleUpdateStatusLine((WindowPtr)consolewindow);    }    return true;  }  return false;}/************************************************************************//*  Purpose..:  Handle update and activate/deactivate events            *//*  Input....:  pointer to an Event                                     *//*  Return...:  true/false                                              *//************************************************************************/static Boolean HandleOSEvents(EventRecord *theEvent){  switch ((theEvent->message >> 24) & 0xff) {  case resumeFlag:    if (theEvent->message & suspendResumeMessage) {      TEActivate(consoleTextWindow->edit);      ShowControl(consoleTextWindow->vscroll);    } else {      TEDeactivate(consoleTextWindow->edit);      HideControl(consoleTextWindow->vscroll);    }    consoleDrawGrowBox((WindowPtr)consolewindow);    consoleUpdateStatusLine((WindowPtr)consolewindow);    return(true);  default:    return(false);  }}#if 0/************************************************************************//*  Purpose..:  Detect a user break (Command-'.')                       *//*  Input....:  pointers an size of block                               *//*  Return...:  true/false                                              *//************************************************************************/static void UserBreak(void){  EventRecord ev;  if (TickCount() - LastTick < TICK_DELTA)    return;  LastTick = TickCount();#ifndef CARBON  if (consoleUseWaitNextEvent)    WaitNextEvent(everyEvent, &ev, 0x0, NULL);  else {    /*  Keep the system happy ... */    SystemTask();    LMSetSEvtEnb(false);    GetNextEvent(everyEvent, &ev);    LMSetSEvtEnb(true);  }#else  WaitNextEvent(everyEvent, &ev, 0x0, NULL);#endif  switch (ev.what) {  case nullEvent:     /*  ignore it ... */    break;#if 0  case keyDown:  case autoKey:       /*  check for break ... */    if (ev.modifiers & cmdKey) {      if ((ev.message & charCodeMask) == '.')        __myraise(SIGINT);      if ((ev.message & charCodeMask) == 'q' || (ev.message & charCodeMask) == 'Q') {        consoleQuitting = true;        __myraise(SIGINT);      }    }    if ((ev.message & charCodeMask) == 0x03 && (ev.message & keyCodeMask) >> 8 != 0x4c)      __myraise(SIGINT);          /*  enter and control c have same char code */        break;#endif  case mouseDown:    HandleMouseDownEvent(&ev);    break;  case activateEvt:  case updateEvt:    HandleUpdateActivateEvent(&ev);    break;  case osEvt:    HandleOSEvents(&ev);    break;  case kHighLevelEvent:#if 0    if (__system7present()) {      AEProcessAppleEvent(&ev);    }#endif    break;  case diskEvt:    if (HiWord(ev.message) != noErr) {      Point pt = {100, 100};#ifndef CARBON      DIBadMount(pt, ev.message);#endif    }    break;  case mouseUp:  case keyUp:  default:    break;  }}#endif/************************************************************************//*  Purpose..:  Insert the current console buffer into the TE Handle      *//*  Input....:  ---                                                     *//*  Return...:  ---                                                     *//************************************************************************/static void InsertconsoleBuffer(void){  TEHandle theTEH = consoleTextWindow->edit;  short teLength;      HLock((Handle)theTEH);  teLength = (*theTEH)->teLength;  if ((teLength + CURRENTBUFSIZE()) >= 30000) {    /*  Insert will grow TEHandle past 32K so we cut out excess from top ... */      char *ptr;    short todelete = (short) ((teLength + CURRENTBUFSIZE()) - 30000) + 8*console_BUFSIZ;            /*  Make sure that the text to be cut ends on a CR ... */      HLock((*theTEH)->hText);    for (ptr = *(*theTEH)->hText + todelete; *ptr != 0x0d; ptr++) ;    /*  We now point at the CR, increment ptr to point after it ... */      todelete += ++ptr - (*(*theTEH)->hText + todelete);    HUnlock((*theTEH)->hText);            /*  We hit the fields directly to keep TE from redrawing twice */      (*theTEH)->selStart = 0;    (*theTEH)->selEnd   = todelete;    TEDelete(theTEH);    /*  Now fix things up... */      teLength = (*theTEH)->teLength;  }  TESetSelect(teLength, teLength, theTEH);  /*  Now insert the new text ... */    TEInsert(consoleBuffer.startpos, CURRENTBUFSIZE(), theTEH);  teLength = (*theTEH)->teLength;  consoleTextWindow->dirty = true;  ZEROconsoleBUFFER();  TESetSelect(teLength, teLength, theTEH);  HUnlock((Handle)theTEH);#if 0  if (consoleSettings.standalone)     UserBreak();  else#endif    consoleUpdateScrollbar();}/************************************************************************//*  Purpose..:  Determine the user's theoretical menuchoice             *//*  Input....:  Character typed                                         *//*  Return...:  Menuchoice                                              *//************************************************************************/static long myMenuKey(char key){  short theMenu = 0;  short theMenuItem = 0;  switch (key) {    /*  File menu choices */    case 's': case 'S':    theMenu = FILEID;    theMenuItem = FILESAVE;    break;  case 'p': case 'P':    theMenu = FILEID;    theMenuItem = FILEPRINT;    break;  case 'q': case 'Q':    theMenu = FILEID;    theMenuItem = FILEQUIT;    break;  case 'x': case 'X':    theMenu = EDITID;    theMenuItem = EDITCUT;    break;  case 'c': case 'C':    theMenu = EDITID;    theMenuItem = EDITCOPY;    break;  case 'v': case 'V':    theMenu = EDITID;    theMenuItem = EDITPASTE;    break;  case 'a': case 'A':    theMenu = EDITID;    theMenuItem = EDITSELECTALL;    break;  }  return (((long)theMenu << 16) | theMenuItem);}/************************************************************************//*  Purpose..:  Check if insertion range is in edit range               *//*  Input....:  first character in edit range                           *//*  Input....:  Handle to textedit                                      *//*  Return...:  true/false                                              *//************************************************************************/Boolean consoleisinrange(short first, TEHandle te){  if (((*te)->selStart < first) || (*te)->selEnd < first) {    SysBeep(10);    return false;  } else    return true;}voidupdate_cursor(Point local_mouse){#ifdef CARBON  Cursor arrow;#endif  if (PtInRect(local_mouse, &(*consoleTextWindow->edit)->viewRect)) {    SetCursor(*GetCursor(iBeamCursor));  } else {#ifndef CARBON    SetCursor(&qd.arrow);#else    GetQDGlobalsArrow(&arrow);    SetCursor(&arrow);#endif  }  if (consoleState == SCANFING) {      TEIdle(consoleTextWindow->edit);  }}  /************************************************************************//* Purpose..: Handles a single event ...                                *//* Input....: If non-zero then pointer to an event                      *//* Returns..: ---                                                       *//************************************************************************/short consoleHandleOneEvent(EventRecord *userevent){  EventRecord theEvent;  WindowPtr   window;  char        aChar;#ifdef CARBON  Cursor      arrow;#endif  if (consoleState == OFF)    return false;  if (userevent) {              /*  External call of the function ... */    theEvent = *userevent;  } else {                      /*  Internal with no WNE allowed ... */#ifndef CARBON    SystemTask();     /* this isn't gonna work */#endif    LMSetSEvtEnb(false);    GetNextEvent(everyEvent, &theEvent);    LMSetSEvtEnb(false);  }  window = FrontWindow();  switch (theEvent.what) {  case nullEvent:    /*  Maintain the cursor */    if (consoleIsAppWindow(window))      {        GrafPtr savePort;        GetPort(&savePort);#ifndef CARBON        SetPort(window);#else           SetPort((GrafPtr)GetWindowPort(window));#endif        GlobalToLocal(&theEvent.where);        update_cursor(theEvent.where);        LocalToGlobal(&theEvent.where);        SetPort(savePort);        return true;      } else {#ifndef CARBON        SetCursor(&qd.arrow);#else        GetQDGlobalsArrow(&arrow);        SetCursor(&arrow);#endif      }    break;  case mouseDown:    if (HandleMouseDownEvent(&theEvent))      return true;    break;  case keyDown:  case autoKey:    if (consoleIsAppWindow(window)) {      aChar = (theEvent.message & charCodeMask);      if (theEvent.modifiers & cmdKey) {#if 0        /*  Check first for command - '.' */        if (consoleState != TERMINATED && aChar == '.')          __myraise(SIGINT);#endif        if (consoleSettings.setupmenus) {          if (console_menubar_installed) {            consoleUpdateMenuItems();          }          consoleDoMenuChoice(MenuKey(aChar));        } else          consoleDoMenuChoice(myMenuKey(aChar));      } else {        if ((theEvent.message & keyCodeMask) >> 8 == 0x4c)          aChar = 0x0d;         /*  map enter key to return key ... */        if (consoleState == SCANFING) {          /*  If there are too many characters on the line already then just return ... */          if (((*consoleTextWindow->edit)->teLength - consoleselstart + 1) >= inputBuffersize) {            SysBeep(10);            return false;          }          switch (aChar) {          case 0x1a:            /*  Control - 'z' */          case 0x04:            /*  Control - 'd' */            /*  Place in the enter key char which will become the EOF */            aChar = 0x03;          case 0x0d:            /*  Carriage Return */            consoleState = IDLE;            break;#if 0          case 0x03:            /*  Control - 'c' */            __myraise(SIGINT);            break;#endif          case 0x08:            /*  Delete */            if (!consoleisinrange(consoleselstart + 1, consoleTextWindow->edit))              return false;            break;          default:            break;          }          /*  if the cursor is currently outside the typeable region then move it ... */          if ((aChar >= ' ') && !consoleisinrange(consoleselstart, consoleTextWindow->edit))            TESetSelect((*consoleTextWindow->edit)->teLength,                        (*consoleTextWindow->edit)->teLength,                        consoleTextWindow->edit);        }        TEKey(aChar, consoleTextWindow->edit);        consoleUpdateScrollbar();        if (aChar < 0x1c || aChar > 0x1f)          consoleTextWindow->dirty = true;        return true;      }    }    break;  case activateEvt:  case updateEvt:    if (HandleUpdateActivateEvent(&theEvent))      return true;    break;  case osEvt:    if (HandleOSEvents(&theEvent))      return true;    break;  case kHighLevelEvent:#if 0    if (__system7present()) {      AEProcessAppleEvent(&theEvent);    }#endif    break;  case diskEvt:    if (HiWord(theEvent.message) != noErr) {      Point pt = {100, 100};#ifndef CARBON      DIBadMount(pt, theEvent.message);#endif    }    break;  case mouseUp:  case keyUp:  default:    break;  }  return false;}short consoleDoSaveText(void){  short error;  HParamBlockRec pb;  SFReply reply;  TEHandle theTE = consoleTextWindow->edit;  long textLength = (long)(*theTE)->teLength;  Point aPoint = {100, 100};#ifdef CARBON  Cursor arrow;#endif  HLock((*theTE)->hText);  if (consoleTextWindow->dirid) {    /*  Open the file ... */    pb.ioParam.ioCompletion = 0L;    pb.ioParam.ioNamePtr = consoleTextWindow->fname;    pb.ioParam.ioVRefNum = consoleTextWindow->vrefnum;    pb.ioParam.ioPermssn = fsWrPerm;    pb.fileParam.ioDirID = consoleTextWindow->dirid;    if (PBHOpenDFSync(&pb) != noErr)      /*  Couldn't open the file so we try resaving it ... */      goto RenameFile;    /*  Write the text ... */    pb.ioParam.ioBuffer = *(*theTE)->hText;    pb.ioParam.ioReqCount = textLength;    pb.ioParam.ioPosMode = fsFromStart;    pb.ioParam.ioPosOffset = 0;    if (PBWriteSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    if (pb.ioParam.ioActCount != (long)(*theTE)->teLength)      goto SaveError;    pb.ioParam.ioMisc = (Ptr)pb.ioParam.ioActCount;    if (PBSetEOFSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    /*  Close file ... */    if (PBCloseSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    goto Saved;  } else {    Str255 theTitle;  RenameFile:    GetWTitle((WindowPtr)consolewindow, theTitle);/* dont bother if CARBON */#ifndef CARBON                  SFPutFile(aPoint, "\pSave document as...", theTitle, 0L, &reply);    /* NavPutFile (NULL, &reply, NULL, NULL, NULL, NULL, 998); */    if (!reply.good)      goto NotSaved;    /*  Make the FSSpec ... */    consoleTextWindow->vrefnum = reply.vRefNum;    consoleTextWindow->dirid = LMGetCurDirStore();    BlockMoveData(reply.fName, consoleTextWindow->fname, reply.fName[0] + 1);    pb.ioParam.ioCompletion = 0L;    pb.ioParam.ioNamePtr = consoleTextWindow->fname;    pb.ioParam.ioVRefNum = consoleTextWindow->vrefnum;    pb.fileParam.ioFlVersNum = 0;    pb.fileParam.ioDirID = consoleTextWindow->dirid;    error = PBHCreateSync(&pb);    if (error != noErr && error != dupFNErr)      goto SaveError;    /*  Set the finder info ... */    pb.fileParam.ioFlCrDat = LMGetTime();    pb.fileParam.ioFlMdDat = LMGetTime();    pb.fileParam.ioFlFndrInfo.fdType = 'TEXT';    pb.fileParam.ioFlFndrInfo.fdCreator = 'CCL2';    pb.fileParam.ioFlFndrInfo.fdFlags = 0;    if (PBHSetFInfoSync(&pb) != noErr)      goto SaveError;    /*  Open the file ... */    pb.ioParam.ioPermssn = fsWrPerm;    if (PBHOpenDFSync(&pb) != noErr)      goto SaveError;    /*  Write the text ... */    pb.ioParam.ioBuffer = *(*theTE)->hText;    pb.ioParam.ioReqCount = textLength;    pb.ioParam.ioPosMode = fsFromStart;    pb.ioParam.ioPosOffset = 0;    if (PBWriteSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    if (pb.ioParam.ioActCount != (long)(*theTE)->teLength)      goto SaveError;    pb.ioParam.ioMisc = (Ptr)pb.ioParam.ioActCount;    if (PBSetEOFSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    /*  Close file ... */    if (PBCloseSync((ParmBlkPtr)&pb) != noErr)      goto SaveError;    /*  Rename the window ... */    SetWTitle((WindowPtr)consolewindow, consoleTextWindow->fname);    goto Saved;#else    goto SaveError;#endif  } SaveError:  HUnlock((*theTE)->hText);#ifdef CARBON  GetQDGlobalsArrow(&arrow);  SetCursor(&arrow);#else  SetCursor(&qd.arrow);#endif  consoleCantSaveAlert(consoleTextWindow->fname); NotSaved:  return (-1); Saved:  HUnlock((*theTE)->hText);  consoleTextWindow->dirty = 0;  return (noErr);}/************************************************************************//* Purpose..: Cleans up the data for a quit ...                         *//* Input....: ---                                                       *//* Returns..: true killed everything/false user cancelled ...           *//************************************************************************/static Boolean consoleCleanUp(void){  short item;  Str255 aString;#ifdef CARBON  Cursor arrow;#endif  if (consoleTextWindow) {    if (consoleTextWindow->dirty && consoleSettings.asktosaveonclose) {      GetWTitle((WindowPtr)consolewindow, aString);#ifdef CARBON      GetQDGlobalsArrow(&arrow);      SetCursor(&arrow);#else      SetCursor(&qd.arrow);#endif      item = consoleYesNoCancelAlert(aString);          switch (item) {      case 1:                   /*  Yes */        if (consoleDoSaveText() != noErr && consoleSettings.standalone) { /*  Save the textWindow ... */          consoleQuitting = false;          return (false);        }        break;      case 3:                   /*  Cancel */        consoleQuitting = false;        return (false);      case 2:                   /*  No */      default:                  /*  error */        break;      }    }    /*  Kill the textWindow ... */    KillControls((WindowPtr)consolewindow);    TEDispose(consoleTextWindow->edit);#ifndef CARBON    CloseWindow((WindowPtr)consolewindow);    DisposePtr((Ptr)consolewindow);#else    DisposeWindow((WindowPtr)consolewindow);#endif        consoleTextWindow = 0L;    ZEROconsoleBUFFER();  }  return (true);}/************************************************************************//*  Purpose..:  Write a string to the console                           *//*  Input....:  pointer to buffer                                       *//*  Input....:  number of chars in buffer                               *//*  Return...:  0 no error / -1 error occurred                          *//************************************************************************/long WriteCharsToConsole(char *buffer, long n){  long counter, i, spacestoinsert;  char aChar;  GrafPtr saveport;  if (consoleQuitting)    return 0;  GetPort(&saveport);#ifndef CARBON  SetPort((WindowPtr)consolewindow);#else  SetPort((GrafPtr)GetWindowPort(consolewindow));#endif  consoleState = PRINTFING;  consoleUpdateStatusLine((WindowPtr)consolewindow);  for(counter = n; counter > 0; counter--)    {      aChar = *buffer++;      switch(aChar) {      case 0x0d:  /*  Line Feed (Mac newline) */        INSERTLINEFEED();        break;      case 0x0a:  /*  Carriage Return (move to start of line) */        i = OffsetOnCurrentLine(consoleTextWindow->edit);        if (i <= CURRENTBUFSIZE()) {          ROLLBACKBUFFER(i);        } else {          consoleBuffer.tepos = (*consoleTextWindow->edit)->teLength - (i - CURRENTBUFSIZE());        }        break;      case '\t':  /*  Tab character */        if (consoleSettings.tabspaces) {          /*  insert spaces for tabs */            CHECKFOROVERFLOW(consoleSettings.tabspaces);          i = OffsetOnCurrentLine(consoleTextWindow->edit);          spacestoinsert = consoleSettings.tabspaces -            (i % consoleSettings.tabspaces);          for (i = 0; i < spacestoinsert; i++) INSERTCHAR(' ');        } else          INSERTCHAR('\t');        break;      case '\f':  /*  Form Feed */        CHECKFOROVERFLOW(consoleTextWindow->linesInFolder);        for (i = consoleTextWindow->linesInFolder; i > 0; i--) INSERTLINEFEED();        break;      case '\a':  /*  Audible Alert */        SysBeep(1);        break;      case '\b':  /*  Backspace */        if (CURRENTBUFSIZE() != 0) {          DELETEFROMBUFFER(1);        } else {                /*  Need to delete the last character from the TextEdit Handle */                                  short teLength = (*consoleTextWindow->edit)->teLength;                                  if (teLength > 0) {                                    TESetSelect(teLength-1, teLength, consoleTextWindow->edit);                                    TEDelete(consoleTextWindow->edit);                                  }                                }        break;      case '\v':  /*  Vertical Tab */        break;      default:    /*  just add it to console ... */        INSERTCHAR(aChar);        break;      }      CHECKFOROVERFLOW(0);    }  InsertconsoleBuffer();  consoleState = IDLE;  consoleUpdateStatusLine((WindowPtr)consolewindow);  SetPort(saveport);  return n;}/************************************************************************//*  Purpose..:  Read characters into the buffer                         *//*  Input....:  pointer to buffer                                       *//*  Input....:  max length of buffer                                    *//*  Return...:  number of characters read / -1 error occurred           *//************************************************************************/long ReadCharsFromConsole(char *buffer, long n){  long charsread;  GrafPtr saveport;  if (consoleQuitting)    return 0;  if (atEOF) {    buffer[0] = EOF;    return 0;  }  GetPort(&saveport);#ifndef CARBON  SetPort((WindowPtr)consolewindow);#else   SetPort((GrafPtr)GetWindowPort(consolewindow));#endif    if (consoleSettings.setupmenus) {    savemenubar = use_menubar(consolemenubar);    console_menubar_installed = true;  }  consoleState = SCANFING;  inputBuffersize = n;  consoleselstart = (*consoleTextWindow->edit)->teLength;  SelectWindow((WindowPtr)consolewindow);  consoleUpdateStatusLine((WindowPtr)consolewindow);  TESetSelect(consoleselstart, consoleselstart, consoleTextWindow->edit);  TEActivate(consoleTextWindow->edit);  consoleUpdateScrollbar();  while (consoleState == SCANFING && !consoleQuitting) {  BackInTheLoop:    consoleHandleOneEvent(NULL);  }          if (consoleQuitting) {    if (!consoleCleanUp()) {      consoleQuitting = false;      goto BackInTheLoop;    }    SetPort(saveport);    exit(0);  }  /*  put the string into the buffer ... */  charsread = (*consoleTextWindow->edit)->teLength - consoleselstart;  BlockMoveData((*(*consoleTextWindow->edit)->hText) + consoleselstart,                buffer,                charsread);  /*  if no error occurred continue else return 0 characters read ... */    if (MemError() == noErr) {      if (buffer[charsread - 1L] == 0x03) /* The user did a Control - Z or control - D (ie an EOF) */        charsread--, atEOF = 1;      else        buffer[charsread - 1L] = 0x0d;    } else {      charsread = 0;    }  consoleUpdateStatusLine((WindowPtr)consolewindow);  use_menubar(savemenubar);  console_menubar_installed = false;  SetPort(saveport);  return charsread;}/* ---------- console driver ---------- *//* *  open_console_driver - install and initialize the console driver * *//*externOSErr DrvrInstall(Handle, short);*//* there ain't no more driverinstall in Carbon and it supposedly never worked and I dunno what it's about */static intopen_console_driver(void){#ifndef CARBON  short i;  DCtlHandle dceH;  register DCtlPtr dce;  OSErr oserr;  /*  create driver on heap  */  if (!drvrH) {    drvr.vCtl.upp.vdoControl = NewdoControlProc(doControl);    drvr.vClose.upp.vdoClose = NewdoCloseProc(doClose);    PtrToHand(&drvr, (Handle *)&drvrH, sizeof(drvr));  }  /*  find available slot in unit table  */  for (i = -28; (dceH = GetDCtlEntry(i)) != NULL; i--) {    if (!dceH) {      break;    }  }  /*    OK, now we have a device driver slot to put the new device driver into    */  HLock( (Handle) drvrH );  oserr = DrvrInstall((DRVRHeaderPtr)(*drvrH), i );  HUnlock( (Handle) drvrH );  dce = *GetDCtlEntry(i);  dce->dCtlDriver = (Ptr) drvrH;  dce->dCtlFlags = drvr.drvrFlags;  dce->dCtlEMask = drvr.drvrEMask;  return(i);#else return(-1);  /* kludge 99 */#endif}/* *  doClose - handle _PBClose call * */static intdoClose(void){   if (consoleCleanUp()) {    console_refnum = 0;    return noErr;  }  return -1;}/************************************************************************//*  Purpose..:  Replacement for mac TE glue                             *//*  Input....:  ---                                                     *//*  Return...:  ---                                                     *//************************************************************************/static OSErr MyTEFromScrap(void){/* lose this for now */#ifndef CARBON  long length, scrapOffset;  if ((length = GetScrap(0L,'TEXT',&scrapOffset))<0)    return (length);  if (length>32000)    return (teScrapSizeErr);  HLock(TEScrapHandle());  if ((length = GetScrap(TEScrapHandle(),'TEXT',&scrapOffset))<0) {    HUnlock(TEScrapHandle());    return (length);  }  HUnlock(TEScrapHandle());  LMSetTEScrpLength(length);#endif  return (noErr);}static OSErr MyTEToScrap(void){#ifndef CARBON  long error;  ZeroScrap();  HLock(TEScrapHandle());  error = PutScrap(LMGetTEScrpLength(), 'TEXT', *TEScrapHandle());  HUnlock(TEScrapHandle());  return error;#else  return (noErr);#endif}/****************************************************************//* Purpose..: Handle the cut menu command                       *//* Input....: ---                                               *//* Returns..: ---                                               *//****************************************************************/void consoleDoEditCut(void){  if (consoleisinrange(consoleselstart, consoleTextWindow->edit) &&       (*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {    TECut(consoleTextWindow->edit);    MyTEToScrap();    consoleTextWindow->dirty = true;    consoleUpdateScrollbar();  }}/****************************************************************//* Purpose..: Handle the copy menu command                      *//* Input....: ---                                               *//* Returns..: ---                                               *//****************************************************************/void consoleDoEditCopy(void){  if ((*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {    TECopy(consoleTextWindow->edit);    MyTEToScrap();  }}/****************************************************************//* Purpose..: Handle the paste menu command                     *//* Input....: ---                                               *//* Returns..: ---                                               *//****************************************************************/void consoleDoEditPaste(void){  if (consoleisinrange(consoleselstart, consoleTextWindow->edit) && MyTEFromScrap() == noErr) {    TEPaste(consoleTextWindow->edit);    consoleTextWindow->dirty = true;    consoleUpdateScrollbar();  }}/****************************************************************//* Purpose..: Handle the clear menu command                     *//* Input....: ---                                               *//* Returns..: ---                                               *//****************************************************************/void consoleDoEditClear(void){  if (consoleisinrange(consoleselstart, consoleTextWindow->edit) &&       (*consoleTextWindow->edit)->selStart != (*consoleTextWindow->edit)->selEnd) {    TEDelete(consoleTextWindow->edit);    consoleTextWindow->dirty = true;    consoleUpdateScrollbar();  }}/****************************************************************//* Purpose..: Handle the select all menu command                *//* Input....: ---                                               *//* Returns..: ---                                               *//****************************************************************/void consoleDoEditSelectAll(void){  TESetSelect(0, 32767, consoleTextWindow->edit);  consoleUpdateScrollbar();}/* *  doControl - handle _PBControl call * */static intdoControl( CntrlParam *pb, DCtlPtr dce ){  register EventRecord *event;  Point mousePos;  switch (pb->csCode) {  case accCursor:    GetMouse(&mousePos);    update_cursor(mousePos);    break;  case accCut:    consoleDoEditCut();    break;  case accCopy:    consoleDoEditCopy();    break;  case accPaste:    consoleDoEditPaste();    break;  case accClear:    consoleDoEditClear();    break;  case accEvent:    event = * (EventRecord **) pb->csParam;    switch (event->what) {    case updateEvt:    case activateEvt:    case keyDown:    case autoKey:      consoleHandleOneEvent(event);      break;    case mouseDown:      HandleMouseDownEvent(event);      break;    }    break;  }#ifndef CARBON  HUnlock((Handle)drvrH);  HUnlock(RecoverHandleSys((Ptr)dce));#endif  return(0);}/************************************************************************//* Purpose..: Check if the window belongs to us                         *//* Input....: Pointer to the window                                     *//* Returns..: true ours                                                 *//************************************************************************/static void FlashControl(ControlHandle theControl){  long aLong;  HiliteControl(theControl, 1);  Delay(3L, &aLong);  HiliteControl(theControl, 0);}/************************************************************************//* Purpose..: Frame a control                                           *//* Input....: Control Handle                                            *//* Returns..: ---                                                       *//************************************************************************/static void FrameControl(ControlHandle theControl){  Rect myRect;      HLock((Handle)theControl);  myRect.top = (*theControl)->contrlRect.top - 4;  myRect.left = (*theControl)->contrlRect.left - 4;  myRect.bottom = (*theControl)->contrlRect.bottom + 4;  myRect.right = (*theControl)->contrlRect.right + 4;  HUnlock((Handle)theControl);      PenNormal();  PenSize(3,3);  FrameRoundRect(&myRect,16,16);  PenNormal();}/************************************************************************//* Purpose..: Check if the window belongs to us                         *//* Input....: Pointer to the window                                     *//* Returns..: true ours                                                 *//************************************************************************/Boolean consoleIsAppWindow(WindowPtr window){  return ((window == (WindowPtr)consolewindow) || false /* check for graphics */);}/************************************************************************//* Purpose..: Handles vertical scrolling                                *//* Input....: Handle to the control                                     *//* Input....: part selected                                             *//* Returns..: ---                                                       *//************************************************************************/static void AdjustText(void){  /*  Since we can only do an adjust text on the textWindow ... */  TEHandle theTE = consoleTextWindow->edit;  short change;      change = (*theTE)->viewRect.top -    (*theTE)->destRect.top -      GetControlValue(consoleTextWindow->vscroll) *        (*theTE)->lineHeight;  if (change != 0) {    TEScroll(0, change, theTE);  }}/************************************************************************//* Purpose..: Handles vertical scrolling                                *//* Input....: Handle to the control                                     *//* Input....: part selected                                             *//* Returns..: ---                                                       *//************************************************************************/static void SetTextView(pconsoleWin theWindow){  TEHandle theTE = theWindow->edit;  /* WindowPtr theWP = (WindowPtr)theWindow; */  WindowPtr theWP = consolewindow;  Rect portRect;#ifdef CARBON    GetWindowPortBounds(theWP, (*theTE)->viewRect);  /* this is wrong  I think */#else       (*theTE)->viewRect = theWP->portRect;#endif  /*  Adjust for the scrollbars ... */  (*theTE)->viewRect.right -= 16;  /*  Adjust for the status line ... */  if (consoleSettings.showstatusline)    (*theTE)->viewRect.top += (*theTE)->lineHeight + 4;#ifndef CARBON    /* why ?? else it creeps down and right when resize the window */  InsetRect(&(*theTE)->viewRect, 4, 4);#endif      theWindow->linesInFolder = ((*theTE)->viewRect.bottom - (*theTE)->viewRect.top) /    (*theTE)->lineHeight;  (*theTE)->viewRect.bottom = (*theTE)->viewRect.top +    ((*theTE)->lineHeight * theWindow->linesInFolder);  (*theTE)->destRect.right = (*theTE)->viewRect.right;  TECalText(theTE);}/************************************************************************//* Purpose..: Draw the framing lines ...                                *//* Input....: Pointer to the window                                     *//* Returns..: ---                                                       *//************************************************************************/void consoleDrawGrowBox(WindowPtr theWindow){  Rect aRect;  short width, height;  GrafPtr savePort;#ifdef CARBON  Rect portRect;#endif  GetPort(&savePort);#ifndef CARBON  SetPort(theWindow);#else  SetPort((GrafPtr)GetWindowPort(theWindow));#endif#ifdef CARBON   GetWindowPortBounds(theWindow, &portRect);  width = portRect.right - portRect.left;  height = portRect.bottom - portRect.top;#else  width = theWindow->portRect.right - theWindow->portRect.left;  height = theWindow->portRect.bottom - theWindow->portRect.top;#endif      SetRect(&aRect, width - 15, -1, width, height);  ClipRect(&aRect);  DrawGrowIcon(theWindow);  ClipRect(&consoleBigRect);  SetPort(savePort);}                /************************************************************************//* Purpose..: Update the window ...                                     *//* Input....: Pointer to the Window                                     *//* Returns..: ---                                                       *//************************************************************************/void consoleUpdateWindow(WindowPtr theWindow){  GrafPtr savePort;#ifdef CARBON  Rect portRect;#endif      GetPort(&savePort);#ifndef CARBON  SetPort(theWindow);#else  SetPort((GrafPtr)GetWindowPort(theWindow));#endif  BeginUpdate(theWindow);#ifdef CARBON  GetWindowPortBounds(theWindow, &portRect);  EraseRect(&portRect);  if (theWindow == (WindowPtr)consolewindow) {    DrawControls(theWindow);    consoleDrawGrowBox(theWindow);    consoleUpdateStatusLine(theWindow);    TEUpdate(&portRect,             consoleTextWindow->edit);  }#else  EraseRect(&theWindow->portRect);  if (theWindow == (WindowPtr)consolewindow) {    DrawControls(theWindow);    consoleDrawGrowBox(theWindow);    consoleUpdateStatusLine(theWindow);    TEUpdate(&theWindow->portRect,             consoleTextWindow->edit);  }#endif  EndUpdate(theWindow);  SetPort(savePort);}/************************************************************************//* Purpose..: Update the Scrollbar's state                              *//* Input....: ---                                                       *//* Returns..: ---                                                       *//************************************************************************/void consoleUpdateScrollbar(void){  short topLineNumber;  short lines;  TEHandle theTE = consoleTextWindow->edit;  topLineNumber = ((*theTE)->viewRect.top - (*theTE)->destRect.top) /    ((*theTE)->lineHeight);      lines = (*theTE)->nLines - consoleTextWindow->linesInFolder;  /*  Following is to correct a bug in TextEdit where if the last char */  /*  is an eol the line count will be wrong ... */  if (((*theTE)->teLength > 0) &&      ((*(*theTE)->hText)[(*theTE)->teLength - 1] == 0x0d))    {      lines++;    }  if (lines < 0) {    lines = 0;  }  SetControlMaximum(consoleTextWindow->vscroll, lines);  SetControlValue(consoleTextWindow->vscroll, topLineNumber);}/************************************************************************//* Purpose..: Handles vertical scrolling                                *//* Input....: Handle to the control                                     *//* Input....: Distance to scroll                                        *//* Returns..: ---                                                       *//************************************************************************/static void MoveScrollBox(ControlHandle theControl, short scrollDistance){  short oldSetting;  short maxValue;  short setting;      oldSetting = GetControlValue(theControl);  maxValue = GetControlMaximum(theControl);  setting = oldSetting - scrollDistance;  if (setting < 0) {    setting = 0;  } else {    if (setting > maxValue) {      setting = maxValue;    }  }  SetControlValue(theControl, setting);}/************************************************************************//* Purpose..: Draws console's status line                                 *//* Input....: Pointer to the window                                     *//* Returns..: ---                                                       *//************************************************************************/void consoleUpdateStatusLine(WindowPtr theWindow){  GrafPtr saveport;  Rect box;  char *state = "console state:";  char *idle = "idle.";  char *printfing = "handling output.";  char *scanfing = "handling input.";  char *terminated = "application has terminated.";  char *aborted = "application has aborted.";  short lineHeight = (*consoleTextWindow->edit)->lineHeight;  short right;#ifdef CARBON  Rect portRect;#endif  if (!consoleSettings.showstatusline)    return;  GetPort(&saveport);#ifndef CARBON  SetPort(theWindow);  /* hmm */#else  SetPort((GrafPtr)GetWindowPort(theWindow));#endif#ifdef CARBON  GetWindowPortBounds(theWindow, &portRect);  right = portRect.right;#else  right = theWindow->portRect.right;#endif    SetRect(&box,0,0,right - 15,lineHeight + 4 - 1);  InsetRect(&box, -1, -1);  ClipRect(&box);  InsetRect(&box, 1, 1);  box.left = 80;  EraseRect(&box);  MoveTo(0, lineHeight + 4 - 1);  Line(right - 15, 0);  TextFont(consoleSettings.fontid);  TextSize(consoleSettings.fontsize);  TextFace(consoleSettings.fontface);  /*  Draw console State: */  MoveTo(4, lineHeight);  DrawText(state,0,strlen(state));  /*  Draw state ... */  MoveTo(80, lineHeight);  switch(consoleState) {  case IDLE:    DrawText(idle,0,strlen(idle));    break;  case PRINTFING:    DrawText(printfing,0,strlen(printfing));    break;  case SCANFING:    DrawText(scanfing,0,strlen(scanfing));    break;  case TERMINATED:    DrawText(terminated,0,strlen(terminated));    break;  case ABORTED:    DrawText(aborted,0,strlen(aborted));    break;  case OFF:  default:    break;  }  ClipRect(&consoleBigRect);  SetPort(saveport);}/************************************************************************//* Purpose..: Grow the window (doesn't draw the bottom line)            *//* Input....: Pointer to window to grow                                 *//* Input....: Initial mouse point                                       *//* Returns..: ---                                                       *//************************************************************************/void consoleMyGrowWindow(WindowPtr theWindow, Point thePoint){  GrafPtr savePort;  Rect scrollRect;#ifdef CARBON  Rect portRect;  #endif  long result;  short lineHeight = (*consoleTextWindow->edit)->lineHeight;  short cntlheight;  GetPort(&savePort);#ifndef CARBON  SetPort(theWindow);#else  SetPort((GrafPtr)GetWindowPort(theWindow));#endif      result = GrowWindow(theWindow, thePoint, &consoleDragRect);  if (result == 0)    return;#ifdef CARBON  GetWindowPortBounds(theWindow, &portRect);#endif#ifdef CARBON  EraseRect(&portRect);#else  EraseRect(&theWindow->portRect);#endif  SizeWindow(theWindow,             (((LoWord(result) - 24) / CharWidth('0')) * CharWidth('0')) + 24,             (((HiWord(result) - 8) / lineHeight) * lineHeight) + 8,             false);#ifdef CARBON   GetWindowPortBounds(theWindow, &portRect);   InvalWindowRect(theWindow, &portRect);#else  InvalRect(&theWindow->portRect);#endif  SetTextView((pconsoleWin)consoleTextWindow);#ifdef CARBON  cntlheight = portRect.top - 1;#else  cntlheight = theWindow->portRect.top - 1;#endif  if (consoleSettings.showstatusline)    cntlheight += lineHeight + 4;#ifdef CARBON MoveControl(consoleTextWindow->vscroll,              portRect.right - 15,              cntlheight);#else  MoveControl(((pconsoleWin)theWindow)->vscroll,              theWindow->portRect.right - 15,              cntlheight);#endif      /*  16 pixels wide and top - bottom of screen plus 1 at both ends ... */#ifdef CARBON  cntlheight = portRect.bottom - portRect.top - 13;#else  cntlheight = theWindow->portRect.bottom - theWindow->portRect.top - 13;#endif  if (consoleSettings.showstatusline)    cntlheight -= lineHeight + 4;  SizeControl(consoleTextWindow->vscroll, 16, cntlheight);  scrollRect = (*((pconsoleWin)consoleTextWindow)->vscroll)->contrlRect;#ifdef CARBON ValidWindowRect(theWindow, &scrollRect);#else  ValidRect(&scrollRect);#endif      consoleUpdateScrollbar();  AdjustText();      SetPort(savePort);}/************************************************************************//* Purpose..: Handles vertical scrolling                                *//* Input....: Handle to the control                                     *//* Input....: part selected                                             *//* Returns..: ---                                                       *//************************************************************************/static pascal void VActionProc(ControlHandle theControl, short part){  /*  Since the graphics window will not have a scrollbar, */  /*  then we can assume that if we are in    this procedure the frontwindow */  /*  is the textWindow ... */  TEHandle theTE = consoleTextWindow->edit;  short scrollAdjust;  if (part == 0) {    return;  }  switch (part) {  case kControlUpButtonPart:  case kControlDownButtonPart:    scrollAdjust = 1;    break;  case kControlPageUpPart:  case kControlPageDownPart:    scrollAdjust = ((*theTE)->viewRect.bottom - (*theTE)->viewRect.top) /      ((*theTE)->lineHeight);    break;  }  if ((part == kControlDownButtonPart) || (part == kControlPageDownPart)) {    scrollAdjust = -scrollAdjust;  }  MoveScrollBox(theControl, scrollAdjust);  AdjustText();}/************************************************************************//* Purpose..: Handles a click in the content region of a window         *//* Input....: The window clicked in ...                                 *//* Input....: The event which occurred ...                              *//* Returns..: ---                                                       *//************************************************************************/void consoleDoContentClick(WindowPtr window, EventRecord *theEvent){  short part;  ControlHandle theControl;  GrafPtr savePort;  GetPort(&savePort);#ifndef CARBON  SetPort(window);#else  SetPort((GrafPtr)GetWindowPort(window));#endif  GlobalToLocal(&theEvent->where);  if ((part = FindControl(theEvent->where, window, &theControl)) == 0) {    /*  Check to see if the user clicked in the textWindow ... */    if (PtInRect(theEvent->where, &((*consoleTextWindow->edit)->viewRect))) {      TEClick(theEvent->where,              (theEvent->modifiers & shiftKey) != 0,              consoleTextWindow->edit);      if (((*consoleTextWindow->edit)->selStart == (*consoleTextWindow->edit)->selEnd) &&          !consoleisinrange(consoleselstart, consoleTextWindow->edit))        {          TESetSelect(consoleselstart, consoleselstart, consoleTextWindow->edit);        }      consoleUpdateScrollbar();    }  } else if (part == kControlIndicatorPart) {    TrackControl(theControl, theEvent->where, 0L);    AdjustText();  } else {    ControlActionUPP tempUPP;#ifndef CARBON           tempUPP = NewControlActionProc(VActionProc);    TrackControl(theControl, theEvent->where, tempUPP);    DisposeRoutineDescriptor(tempUPP);#else   tempUPP = (ControlActionUPP)NewControlActionUPP(VActionProc); /* why cast needed? */   TrackControl(theControl, theEvent->where, tempUPP);    DisposeControlActionUPP(tempUPP);#endif  }  SetPort(savePort);}/************************************************************************//* Purpose..: Initialize the console textWindow                           *//* Input....: Number of columns                                         *//* Input....: Number of rows                                            *//* Returns..: true the window was initialized                           *//************************************************************************/Boolean consoleSetupTextWindow(void){  Rect aRect = {0,0,1,1};  FontInfo fi;  short lineHeight, screenHeight, screenWidth;  ProcessSerialNumber psn;  ProcessInfoRec pinfo;  OSErr err;  Str63   AppName;  GrafPtr saveport;/*  Ptr pigfucker; */  #ifdef CARBON  BitMap  screenBits;  GetQDGlobalsScreenBits(&screenBits);#endif  /*  Get process Info */  GetPort(&saveport);  err = GetCurrentProcess(&psn);  pinfo.processName = AppName;  pinfo.processInfoLength = sizeof(pinfo);  pinfo.processAppSpec = NULL;  err = GetProcessInformation(&psn,&pinfo);    if (pinfo.processName[0] <= 50) {    pinfo.processName[++(pinfo.processName[0])] = ' ';    pinfo.processName[++(pinfo.processName[0])] = 'c';    pinfo.processName[++(pinfo.processName[0])] = 'o';    pinfo.processName[++(pinfo.processName[0])] = 'n';    pinfo.processName[++(pinfo.processName[0])] = 's';    pinfo.processName[++(pinfo.processName[0])] = 'o';    pinfo.processName[++(pinfo.processName[0])] = 'l';    pinfo.processName[++(pinfo.processName[0])] = 'e';    pinfo.processName[++(pinfo.processName[0])] = '-';    pinfo.processName[++(pinfo.processName[0])] = '0' + (console_seq / 10);    pinfo.processName[++(pinfo.processName[0])] = '0' + (console_seq % 10);  }  console_seq++;  if (*AppName == 0) {    BlockMoveData("\pconsole TextWindow", AppName, 17L);  }  /*  Initialize the TextWindPtr ... */  consoleTextWindow = (pconsoleWin)NewPtr(sizeof(tconsoleWin));    if (consoleTextWindow == 0)    return false;  /*  consoleTextWindow = &consoleTextWindowBuf */  consolewindow = NewWindow(0L, &aRect, AppName, false,                documentProc, (WindowPtr)0L, true, 0L);  if (consolewindow == 0L)    { Debugger ();    return(false);}  consoleTextWindow->windowptr = consolewindow;  #ifndef CARBON  SetPort((WindowPtr)consolewindow);#else  SetPort((GrafPtr)GetWindowPort(consolewindow));#endif   /*  Set the font information ... */  TextFont(consoleSettings.fontid);  TextSize(consoleSettings.fontsize);  TextFace(consoleSettings.fontface);  GetFontInfo(&fi);  lineHeight = fi.ascent + fi.descent + fi.leading;  /*  Size the window ... */  consoleSettings.columns = (consoleSettings.columns <= 0) ? 80 : consoleSettings.columns;  consoleSettings.rows = (consoleSettings.rows <= 0) ? 24 : consoleSettings.rows;  if (consoleSettings.showstatusline)    aRect.bottom = 2*4 + (consoleSettings.rows + 1)*lineHeight + 4; /*  2*indent + ... + titlebar */  else    aRect.bottom = 2*4 + (consoleSettings.rows)*lineHeight + 4; /*  2*indent + ... + titlebar */  aRect.right = 2*4 + consoleSettings.columns*CharWidth('0') + 16, /*  2*indent + ... + scrollbar */#ifndef CARBON  screenHeight = qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - GetMBarHeight() - 24; /*  screen height ... */  screenWidth = qd.screenBits.bounds.right - qd.screenBits.bounds.left;#else  screenHeight = screenBits.bounds.bottom - screenBits.bounds.top - GetMBarHeight() - 24;  screenWidth = screenBits.bounds.right - screenBits.bounds.left;#endif  if (aRect.bottom > screenHeight)    aRect.bottom = ((screenHeight - 2*4 - 4) / lineHeight) * lineHeight + 2*4 + 4;  /*  Move the window to the correct place ... */  if (consoleSettings.toppixel == 0 && consoleSettings.leftpixel == 0) {    if (aRect.right > screenWidth) /*   The window is wider than the screen */      aRect.right = ((screenWidth - 2*4 - 16 - 20) / CharWidth('0')) * CharWidth('0') + 2*4 + 16;#ifndef CARBON    MoveWindow ((WindowPtr)consolewindow,                ((qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2),                ((screenHeight - aRect.bottom) / 5 + GetMBarHeight() + 24),                false);#else   MoveWindow ((WindowPtr)consolewindow,                ((screenBits.bounds.right - screenBits.bounds.left - aRect.right) / 2),                ((screenHeight - aRect.bottom) / 5 + GetMBarHeight() + 24),                false);#endif  } else    MoveWindow ((WindowPtr)consolewindow,                consoleSettings.leftpixel, consoleSettings.toppixel,                false);  /*  Now make it the correct size ... */  SizeWindow((WindowPtr)consolewindow, aRect.right, aRect.bottom, true);  /*  Create the vertical scrollbar ... */#ifdef CARBON GetWindowPortBounds(((WindowPtr)consolewindow), &aRect);#else  aRect = ((WindowPtr)consolewindow)->portRect;#endif  aRect.left = aRect.right - 15;  aRect.right += 1;  aRect.bottom -= 14;  aRect.top -= 1;  if (consoleSettings.showstatusline)    aRect.top += lineHeight + 4; /*  factor in the status window ... */  consoleTextWindow->vscroll = NewControl((WindowPtr)consolewindow, &aRect, "\p",                                        true, 0, 0, 0, scrollBarProc, 0L);  ShowWindow((WindowPtr)consolewindow);  /*  Create the TEHandle ... */#ifdef CARBON  GetPortBounds(GetQDGlobalsThePort(), &aRect);#else  aRect = qd.thePort->portRect;#endif  aRect.right -= 15;  if (consoleSettings.showstatusline)    aRect.top += lineHeight + 4;  InsetRect(&aRect, 4, 4);  consoleTextWindow->edit = TENew(&aRect, &aRect);  TEAutoView(true, consoleTextWindow->edit);      consoleTextWindow->linesInFolder = consoleSettings.rows; /*  Number of lines visible ... */  consoleTextWindow->dirty = 0;   /*  Window is clean ... */  consoleTextWindow->dirid = 0;   /*  Window hasn't been saved yet ... */  if (console_refnum == 0) {    console_refnum = open_console_driver();  }#ifndef CARBON  ((WindowPeek)consolewindow)->windowKind = -1;#else  SetWindowKind(consolewindow, -1);#endif  consoleUpdateWindow((WindowPtr)consolewindow);  SetPort(saveport);  return(true);}/****************************************************************//* Purpose..: Display an alert style window                     *//* Input....: Do we initialize the toolbox                      *//* Input....: The window's rectangle                            *//* Returns..: true the window was opened                        *//****************************************************************/void consoleCantSaveAlert(Str63 filename){  WindowPtr wp, theWindow;  GrafPtr savePort;  EventRecord theEvent;  Handle theIcon;  ControlHandle okButton, dummyCntl;  Rect aRect = {0, 0, 75, 270};  Boolean done = false;  char aString[100] = "An error occurred while saving '";  short length;  short height, width;#ifdef CARBON  Cursor arrow;  BitMap screenBits;    GetQDGlobalsArrow(&arrow);  GetQDGlobalsScreenBits(&screenBits);  SetCursor(&arrow);#else  SetCursor(&qd.arrow);#endif    GetPort(&savePort);      /*  Center it horizontally and 20% down vertically */#ifndef CARBON  width = (qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2;  height = (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - GetMBarHeight() - aRect.bottom) / 5 + GetMBarHeight();#else  width = (screenBits.bounds.right - screenBits.bounds.left - aRect.right) / 2;  height = (screenBits.bounds.bottom - screenBits.bounds.top - GetMBarHeight() - aRect.bottom) / 5 + GetMBarHeight();#endif       OffsetRect(&aRect, width, height);      /*  Create a simple window with an OK button */  if ((wp = NewWindow(0L, &aRect, "\p", true, dBoxProc,                      (WindowPtr)-1L, false, 0L)) == 0L)    {      SysBeep(10);      return;    }#ifndef CARBON  SetPort(wp);#else  SetPort((GrafPtr)GetWindowPort(wp));#endif  TextFont(0);  TextSize(12);  TextFace(0);  SetRect(&aRect, 50, 4, 260, 46);  length = strlen(aString);  BlockMoveData(&filename[1], &aString[length], filename[0]);  aString[length + filename[0] + 1] = '\0';  strcat(aString, "'.");  TETextBox(aString, strlen(aString), &aRect, teForceLeft);  SetRect(&aRect, 8, 8, 40, 40);  theIcon = GetIcon(0);  PlotIcon(&aRect, theIcon);  SetRect(&aRect, 105, 50, 165, 68);  okButton = NewControl(wp, &aRect, "\pOK", true, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);  /*  Outline the default button ... */  FrameControl(okButton);      while (!done) {    if(GetNextEvent(mDownMask | keyDownMask, &theEvent)) {      if (theEvent.what == mouseDown) {        if ((FindWindow(theEvent.where, &theWindow) == inContent) && (theWindow == wp)) {          GlobalToLocal(&theEvent.where);          if (FindControl(theEvent.where, wp, &dummyCntl) == kControlButtonPart)            if (TrackControl(dummyCntl, theEvent.where, 0L) != 0) {              done = true;            }        }      } else if (theEvent.what == keyDown) {        char key;                        key = theEvent.message & charCodeMask;        if (key == 0x0d || key == 0x03) {          FlashControl(okButton);          done = true;        }      }    }  }      DisposeControl(okButton);  DisposeWindow(wp);  ReleaseResource(theIcon);  SetPort(savePort);}/****************************************************************//* Purpose..: Ask the user if he/she wishes to save             *//* Input....: The name of the file                              *//* Returns..: Yes, No, Cancel                                   *//****************************************************************/short consoleYesNoCancelAlert(Str63 filename){  WindowPtr wp, theWindow;  GrafPtr savePort;  EventRecord theEvent;  Handle theIcon;  short item;  ControlHandle yesButton, noButton, cancelButton, dummyCntl;  Rect aRect = {0, 0, 89, 386};  char aString[110] = "Save window '";  Boolean done = false;  short length;  short height, width;#ifdef CARBON  Cursor arrow;  BitMap screenBits;  GetQDGlobalsArrow(&arrow);  GetQDGlobalsScreenBits(&screenBits);  SetCursor(&arrow);#else  SetCursor(&qd.arrow);#endif  GetPort(&savePort);      /*  Center it horizontally and 20% down vertically */#ifndef CARBON  width = (qd.screenBits.bounds.right - qd.screenBits.bounds.left - aRect.right) / 2;  height = (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top - GetMBarHeight() - aRect.bottom) / 5 + GetMBarHeight();#else   width = (screenBits.bounds.right - screenBits.bounds.left - aRect.right) / 2;   height = (screenBits.bounds.bottom - screenBits.bounds.top - GetMBarHeight() - aRect.bottom) / 5 + GetMBarHeight();#endif  OffsetRect(&aRect, width, height);      /*  Create a simple window without button ... */  if ((wp = NewWindow(0L, &aRect, "\p", true, dBoxProc,                      (WindowPtr)-1L, false, 0L)) == 0L)    {      SysBeep(10);      return (-1);    }#ifndef CARBON  SetPort(wp);#else  SetPort((GrafPtr)GetWindowPort(wp));#endif  /*  Draw the text box ... */  TextFont(0);  TextSize(12);  TextFace(0);  SetRect(&aRect, 78, 12, 373, 44);  length = strlen(aString);  BlockMoveData(&filename[1], &aString[length], filename[0]);  aString[length + filename[0] + 1] = '\0';  strcat(aString, "' before quitting?");  TETextBox(aString, strlen(aString), &aRect, teForceLeft);  /*  Draw the icon */  SetRect(&aRect, 23, 12, 55, 44);  theIcon = GetIcon(2);  PlotIcon(&aRect, theIcon);  if (consoleSettings.standalone) {    /*  Draw the Don't Save button ... */    SetRect(&aRect, 78, 57, 158, 77);    noButton = NewControl(wp, &aRect, "\pDon't Save", true, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);    /*  Draw the Cancel button ... */    SetRect(&aRect, 245, 57, 304, 77);    cancelButton = NewControl(wp, &aRect, "\pCancel", true, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);  } else {    /*  Draw the Don't Save button ... */    SetRect(&aRect, 224, 57, 304, 77);    noButton = NewControl(wp, &aRect, "\pDon't Save", true, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);  }  /*  Draw the Save button ... */  SetRect(&aRect, 314, 57, 374, 77);  yesButton = NewControl(wp, &aRect, "\pSave", true, 0, 0, 0, pushButProc|kControlUsesOwningWindowsFontVariant, 0);  /*  Outline the default button ... */  FrameControl(noButton);  while (!done) {    if(GetNextEvent(mDownMask | keyDownMask, &theEvent)) {      if (theEvent.what == mouseDown) {        if ((FindWindow(theEvent.where, &theWindow) == inContent) && (theWindow == wp)) {          GlobalToLocal(&theEvent.where);          if (FindControl(theEvent.where, wp, &dummyCntl) == kControlButtonPart)            if (TrackControl(dummyCntl, theEvent.where, 0L) != 0) {              if (dummyCntl == yesButton)                item = 1;              if (dummyCntl == noButton)                item = 2;              if (consoleSettings.standalone && dummyCntl == cancelButton)                item = 3;              done = true;            }        }      } else if (theEvent.what == keyDown) {        char key;                        key = theEvent.message & charCodeMask;        if (key == 'Y' || key == 'y' || key == 'S' || key == 's') {          item = 1;          FlashControl(yesButton);          done = true;        } else if (key == 'N' || key == 'n' ||                   key == 'D' || key == 'd' ||                   key == 0x0d || key == 0x03) {          /*  CR or ENTER key go here */          item = 2;          FlashControl(noButton);          done = true;        } else if (consoleSettings.standalone) {          if ((key == '.' && (theEvent.modifiers & cmdKey)) || (key == 0x1b)) {            /*  ESCAPE key or command - . go here */            item = 3;            FlashControl(cancelButton);            done = true;          }        }      }    }  }      DisposeControl(yesButton);  DisposeControl(noButton);  if (consoleSettings.standalone)    DisposeControl(cancelButton);  DisposeWindow(wp);  ReleaseResource(theIcon);  SetPort(savePort);  return (item);}static voidensure_console_window_exists(){  if (consoleTextWindow == NULL) {    consoleSetupTextWindow();  }    ShowHide((WindowPtr)(consolewindow), true);}static char *console_name = "dev:console";int32console_faccess(char *name, unsigned int cmd, long *arg){#ifdef SUPPORT_PRAGMA_UNUSED#pragma unused(arg)#endif  if (EqualString(name, console_name, false, true)) {    if (cmd == F_OPEN) {      return 0;    }    return 0x40000016;  }  return -1;}int32console_close(MPWIOEntry * entry){#ifdef SUPPORT_PRAGMA_UNUSED#pragma unused(entry)#endif  return 0;}int32 console_read(MPWIOEntry * entry){  int num_read = ReadCharsFromConsole((char *) (entry->buffer), entry->length);  entry->length -= num_read;  return 0;}int32 console_write(MPWIOEntry * entry){  ensure_console_window_exists();  WriteCharsToConsole((char *) (entry->buffer), entry->length);  entry->length = 0;  return 0;}int32 console_ioctl(MPWIOEntry * entry, unsigned int cmd, long *arg){#ifdef SUPPORT_PRAGMA_UNUSED#pragma unused (entry)#endif  switch (cmd) {  case FIOBUFSIZE:    *arg = 255;    /* fall in */  case FIOINTERACTIVE:    return 0;  default:    return -1;  }}char _console_buffer[console_BUFSIZ];voidinstall_console(void){  MenuHandle m; if (!is_osx())  {  fclose(stdin);  fclose(stdout);  fclose(stderr);  _addDevHandler(1, 'CONS', console_faccess, console_close, console_read, console_write, console_ioctl);  consoleBuffer.startpos = _console_buffer;  ZEROconsoleBUFFER(); freopen(console_name,"r",stdin);  freopen(console_name,"w",stdout);  freopen(console_name,"w",stderr);  setvbuf(stderr,NULL,_IOLBF,0); }    if (consoleSettings.setupmenus) {    /* Set up the console menubar */    m = NewMenu(APPLEID,"\p");#ifndef CARBON    AppendResMenu(m, 'DRVR');#endif    InsertMenu(m, 0);    appleMenu = m;        m = NewMenu(FILEID, "\pFile");    AppendMenu(m, "\p(New...;(Open...;(Close...;Save/S;(-;Page Setup;Print.../P;(-;Quit/Q");    InsertMenu(m, 0);    fileMenu = m;        m = NewMenu(EDITID, "\pEdit");    AppendMenu(m, "\p(Undo/Z;(-;(Cut/X;(Copy/C;Paste/V;(Clear;(-;Select All/A");    InsertMenu(m, 0);    editMenu = m;        consolemenubar = GetMenuBar();    HandToHand(&consolemenubar);  /* make a copy */    ClearMenuBar();               /* empty the original */  }}#endif /* CONSOLE */