; -*- Mode: Lisp; Package: CCL -*-

;;	Change History (most recent first):
;;  3 2/17/95  slh  relaxed %lap-words constraints
;;  (do not edit before this line!!)

; lap.lisp - Lisp Assembly Programming

; Copyright 1986-1987 Coral Software Corp.
; Copyright 1988-1994 Apple Computer, Inc.
; Copyright 1995 Digitool, Inc.

; Modification History
;
; 10/20/95 slh  empty for PPC
;  4/21/95 slh  require lispequ
;  2/17/95 slh  %lap-words: ease up on "no immediates" test
; ------------- 3.0d17
; 04/23/94 bill in deflapop, (parse-body body nil) => (parse-body body env nil)
; ------------- 3.0d13
; 12/18/92 bill in %lap-words - prevent immediates generated by *save-local-symbols*
; 11/20/92 gb   q2; new lap-words.
; 08/26/92 bill (move16 Ax@+ Ay@+) from Steve Mitchell
;-------------  2.0
; 07/21/91 gb  bitfield instructions.
; 06/21/91 bill add move to/from sr/ccr
; 06/10/91 bill MULx.L, DIVx.L
;-------------- 2.0b2
; 05/20/91 gb  recognize short-float constants.  Look for FPU ops (operand
;              parsing still not right for, e.g., constants).
;02/18/91 gb   %uvsize -> uvsize.
; 10/16/90 gb  no more %str-length.
; 06/26/90 bill add (and/or ($ n) sr/ccr)
; 04/30/90 gb  TRAPV, nx8* -> nx*, check labels for operator conflict.
; 04/14/90 gz  %substr now takes start/end, change %subsym accordingly.
; 01/17/90 gz  $lfatr-noname-bit.
; 11/20/89 gz  use hash tables instead of plists.
; 10/18/89 gz  Record source file in deflapgen, deflapop.
;              Allow duplicate *lap-labels*, for the sake of with-local-labels.
; 09/29/89 gz  Allow (An (reg l) data) for indirect operands.
; 09/27/89 gb  typo in lap-bit-instr.
; 05/22/89 gz  with-local-labels.
; 04/24/89 gz  btst.w.  Keep track of immediate instructions.
;              %lap-words shouldn't blow up when *save-definitions* is on...
; 03/09/89 gz  Added moveq.
;              (btst.l ($ n) <memory>) tries to do something reasonable.
; 02/12/89 gz  Added lap-freg-op[-p]
; 01/02/89 gz  Allow reg name in lap-register-mask
; 12/13/88 gz  Added lap-list/lap-vector.
; 12/12/88 gz  delay nilreg lookups til code generation.
; 12/11/88 gz  call nx-transform on absolute values.
; 11/23/88 gb  something about unsigned-bytes.
; 9/27/88  gb  d2 == dx.
; 9/23/88  gb  8.9 upload.
; 9/13/88  gb  a4 is nilreg, d4 Xnilreg for now.
; 8/16/88  gz  Reorganized compiler interface somewhat, for better handling of
;              immediates and labels.
; 8/10/88  gz  support for FP registers (but not instructions).
;              Added (-@ areg), (@+ areg) as synonyms for -@areg, areg@+.
;              Optimize move.l -4(An),An to move.l -(An),An
; 8/9/88   gz  ($ #\x) means character code.  '#\x is boxed Lisp char.
;              More ops handle compiler modes.
; 8/4/88   gb  lap-shift-instr : set i/r bit vice dr when count is reg.
; 4/19/88  gz  added movem
; 7/16/87  gz  nc-a5immaddr => nx2-immediate-a5addr
; 7/12/87  gb  Provide thyself.
; 7/06/87  gb  stop using %s1arrays.
; 6/12/87  gb  count -> bit in lap-bit-instr. size -> size6 in lap-shift-instr.
;              Proclaim all specials.
; 6/06/87  gb  new $LF_USUALP, stop accounting for lfun-plists; change lfun-bits in lap fns.
; 6/05/87  gb  31-bit fixnums.
; 4/29/87  gb  no %lap-inline for now.
; 4/28/87  gz  mods to simplify bootstrapping.
; 4/16/87  gz  fix in lap-long
; 4/6/87   gz  converted ERROR calls.
; 2/20/87  gz  added %lap-words.
; 02/07/87 gb  %apply -> apply.
; 02/05/87 gz  %member -> memq, %assoc -> assq.
; 01/30/87 gz  %str-char -> schar
; 01/17/87 gz  dbcc; use lisp version of %lap-expr if eval, lap if compile.
; 01/14/87 gb  %get -> get.
; 01/11/87 gz  %list-length -> list-length, renamed .gen to dc.w
; 01/03/87 gz  %haddsym -> intern, sigh.
; 12/27/86 gz  New file.

(in-package :ccl)

#-ppc-target
(progn

(eval-when (eval compile)
  (require :lispequ)
  (require :level-2)
  (require :backquote)

  (defmacro cur-size (&optional shift)
    (if (null shift) '(or *lap-cur-size* 1)
        (list '%ilsl shift '(or *lap-cur-size* 1))))
  
  (defconstant $dreg_mode #o00)
  (defconstant $areg_mode #o10)
  (defconstant $ind_mode #o20)
  (defconstant $pop_mode  #o30)
  (defconstant $push_mode #o40)
  (defconstant $rel_mode  #o50)
  (defconstant $idx_mode  #o60)
  (defconstant $abs.w_mode #o70)
  (defconstant $abs.l_mode #o71)
  (defconstant $pcrel_mode #o72)
  (defconstant $pcidx_mode #o73)
  (defconstant $imm_mode   #o74)
  (defconstant $lisploc_mode #o75)
  (defconstant $lispimm_mode #o76)
  (defconstant $label_ref_mode #o171)
  (defconstant $reg_list_mode #o172)
  (defconstant $fpreg_mode #o173)
  (defconstant $fpreg_list_mode #o174)
  
  (defconstant $reg_mask   #o07)
  (defconstant $mode_mask  #o70)
  
  (defconstant $spush_mode #o47)
  
  (defmacro dregp (mode) `(%i< ,mode $areg_mode))
  (defmacro aregp (mode) `(eq $areg_mode (%ilogand2 $mode_mask ,mode)))
  (defmacro regp (mode) `(%i< ,mode $ind_mode))
  
  (defmacro sign-word (word) `(if (%ilogbitp 15 ,word) #xFFFF 0))
  )

(eval-when (eval compile load)
  
  (defmacro deflaplfun (name bits &rest forms)
    `(fset ',name (nfunction ,name (lambda (&lap ,bits) (old-lap ,@forms)))))
  
  (defmacro deflapgen (name args &rest body &environment env)
    (multiple-value-bind (body decls) (parse-body body env nil)
      `(progn
         ,(if body
            `(setf (gethash ',name *lapgens*)
                   (nfunction ,name (lambda ,args ,@decls (block ,name ,@body))))
            `(setf (gethash ',name *lapgens*) ,args))
         (record-source-file ',name 'lap)
         ',name)))
  
  (defmacro deflapfpgen (name args &rest body &environment env)
    (multiple-value-bind (body decls) (parse-body body env nil)
      `(progn
         ,(if body
            `(setf (gethash ',name *lapfpgens*)
                   (nfunction ,name (lambda ,args ,@decls (block ,name ,@body))))
            `(setf (gethash ',name *lapfpgens*) ,args))
         (record-source-file ',name 'lap)
         ',name)))
  
  (defmacro deflapop (name args &rest body &environment env)
    (multiple-value-bind (body decls) (parse-body body env nil)
      `(progn
         ,(if body
            `(setf (gethash ',name *lapops*)
                   (nfunction ,name (lambda ,args ,@decls (block ,name ,@body))))
            `(setf (gethash ',name *lapops*) ,args))
         (record-source-file ',name 'lap)
         ',name)))
  )

(defvar *lapgens* (make-hash-table :test #'eq))
(defvar *lapfpgens* (make-hash-table :test #'eq))
(defvar *lapops* (make-hash-table :test #'eq))

(defparameter *lap-dregs* '((d0 . 0) (d1 . 1) (d2 . 2) (d3 . 3)
                            (d4 . 4) (d5 . 5) (d6 . 6) (d7 . 7)
                            (nargs . 4) (acc . 0)
                            (arg_x . 2) (arg_y . 1) (arg_z . 0) (da . 3) 
                            (db . 4) (dx . 2) (dy . 1) (dsave0 . 5)
                            (dsave1 . 6) (dsave2 . 7) (dtemp0 . 0)
                            (dtemp1 . 1) (dtemp2 . 2) (dtemp3 . 3)))

(defparameter *lap-aregs* '((a0 . 0) (a1 . 1) (a2 . 2) (a3 . 3)
                            (a4 . 4) (a5 . 5) (a6 . 6) (a7 . 7)
                            (nilreg . 4) (vsp . 6) (sp . 7) 
                             (atemp0 . 0) (atemp1 . 1) (asave0 . 2) (asave1 . 3)))

(defparameter *lap-fpregs* '((fp0 . 0) (fp1 . 1) (fp2 . 2) (fp3 . 3)
                             (fp4 . 4) (fp5 . 5) (fp6 . 6) (fp7 . 7)
                             (fpcr . 8) (fpsr . 9) (fpiar . 10)))

(declaim (special *lap-cur-size* *lap-cur-instr* *lap-cur-fp-size*))

(defun lap-instr (instr)
  (let ((*lap-cur-instr* instr))
    (if (atom instr)
      (if (or (symbolp instr) (integerp instr))
        (%lap-label instr)
        (lap-error "Bad label"))
      (apply #'%lap-expr instr))))

(defun %lap-label (label)
  (when (symbolp label)
    (let* ((name label)
           (str (symbol-name name))
           (len (%i- (length str) 2)))
      (when (and (%i> len 0)
                 (eq (schar str len) #\.))
        (setq name (%subsym name 0 len)))
      (when (or (gethash name *lapgens*) (gethash name *lapfpgens*))
        (warn "Lap label ~s is also defined as an operation." label))))
  (lap-gen-label label))

(defun %lap-expr (name &rest args) 
  (declare (dynamic-extent args))
  (let* ((str (symbol-name name))
         (len (length str))
         size fpsize op ch)
    (when (and (%i> len 2)
               (eq (schar str (%i- len 2)) #\.)
               (progn
                 (setq size (%cdr (assq (setq ch (schar str (%i- len 1)))
                                        '((#\B . 0) (#\W . 1) (#\L . 2)))))
                 (setq fpsize (%cdr (assq ch '((#\L . 0) (#\S . 1) (#\X . 2)
                                               (#\P . 3) (#\W . 4) (#\D . 5) (#\B . 6)))))
                 (or size fpsize)))
      (setq name (%subsym name 0 (%i- len 2))))
    (setq *lap-cur-size* size)
    (unless (setq op (gethash name *lapgens*))
      (setq *lap-cur-fp-size* fpsize)
      (unless (setq op (gethash name *lapfpgens*))
        (lap-error "Unknown operator ~S" name)))
    (apply op args)))

;Enter a new local labels scope.  Labels defined inside go away when exit scope.
;*** assumes going thru compiler....
(deflapgen with-local-labels (&rest instructions)
  (declare (special *nx2-labels*))
  (let* ((start-labels (remove-if #'(lambda (label)
                                      (eq -1 (aref *nx2-labels* (%cdr label))))
                                  *lap-labels*))
         (end-labels (let ((*lap-labels* start-labels))
                       (dolist (instr instructions) (lap-instr instr))
                       *lap-labels*)))
    (until (eq end-labels start-labels)
      (when (eq -1 (aref *nx2-labels* (%cdar end-labels)))
        (push (%car end-labels) *lap-labels*))
      (setq end-labels (%cdr end-labels)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun lap-instr-gen (instr mode ext1 ext2)
  (cond ((eq mode $lisploc_mode)
         (unless (eq *lap-cur-size* 2) (lap-error "Bad instruction size"))
         (lap-gen-locref instr ext1))
        ((eq mode $lispimm_mode)
         (unless (eq *lap-cur-size* 2) (lap-error "Bad instruction size"))
         (lap-gen-immref instr ext1))
        ((eq mode $label_ref_mode)
         (lap-gen (%ilogior instr $pcrel_mode))
         (lap-gen-labref ext1 ext2))
        (T (lap-gen (%ilogior instr mode) ext1 ext2))))

(defun lap-imminstr-gen (instr srcmode srcext1 srcext2 dstmode dstext1 dstext2)
  (unless (or (eq *lap-cur-size* 2) (and (neq srcmode $lispimm_mode)
                                         (neq dstmode $lisploc_mode)))
    (lap-error "Bad instruction size"))
  (if (eq dstmode $lisploc_mode)
    (lap-gen-immlocref instr srcmode srcext1 srcext2 dstext1)
    (progn
      (lap-gen (%ilogior instr dstmode))
      (if (eq srcmode $lispimm_mode)
        (lap-gen-abs-immref srcext1 nil)
        (lap-gen srcext1 srcext2))
      (lap-gen dstext1 dstext2))))

(deflapgen dc (&rest words)
  (if (and *lap-cur-size* (neq *lap-cur-size* 1))
    (if (eq *lap-cur-size* 2)
      (dolist (word words)
        (nx2-lap-gen-abs-immref word 0))
      (lap-error "Not implemented yet"))
    (dolist (word words)
      (when word
        (lap-gen (lap-uns-word (lap-abs-val word)))))))

; Two "quick" instructions may be faster/smaller than one "slow" one.
(deflapgen q2 (op imm dest inverse)
  (let* ((operator op)
         (value (multiple-value-bind (mode ext1 ext2) (lap-std-operand imm)
                  (unless (and (eq $imm_mode mode) (eq ext1 (sign-word ext2)))
                    (lap-error "Bad count operand ~S" imm))
                  (if (%izerop ext1) ext2 (%i- ext2 #x10000)))))
    (if (< value 0) (setq value (abs value) operator inverse))
    (setq value (require-type value '(integer 1 15)))
    (when (> value 8)
      (%lap-expr operator '($ 8) dest)
      (setq value (- value 8)))
    (%lap-expr operator `($ ,value) dest)))

(deflapgen moveq (src dst)
  (when (and *lap-cur-size* (neq *lap-cur-size* 2)) (lap-error))
  (lap-gen (%ilogior #o70000
                     (%ilsl 9 (lap-dreg-op dst))
                     (lap-byte-op src))))

(deflapgen move (src dst &aux (size (cur-size)))
  (if (or (eq src 'sr) (eq src 'ccr)
          (eq dst 'sr) (eq dst 'ccr))
    (progn
      (unless (eq size 1)
        (lap-error))
      (if (or (eq src 'sr) (eq src 'ccr))
        (multiple-value-bind (mode ext1 ext2) (lap-dest-op dst)
          (lap-instr-gen (if (eq src 'sr) #o40300 #o41300) mode ext1 ext2))
        (multiple-value-bind (mode ext1 ext2) (lap-source-op src)
          (lap-instr-gen (if (eq src 'sr) #o43300 #o42300) mode ext1 ext2))))
    (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
      (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
        (when (and (eq size 2) (aregp dstmode))
          (when (and (eq srcmode $imm_mode) (eq srcext1 (sign-word srcext2)))
            ;move.l #nn,An = move.w #nn,An if nn is a word!
            (setq size 1 srcext1 srcext2 srcext2 nil))
          (when (and (eq srcext1 #xFFFC)
                     (eq (%ilogand $mode_mask srcmode) $rel_mode)
                     (eq (%ilogand $reg_mask srcmode) (%ilogand $reg_mask dstmode)))
            ;move.l -4(An),An = move.l -(An),An!
            (setq srcmode (%ilogior $push_mode (%ilogand $reg_mask srcmode))
                  srcext1 nil)))
        (cond ((and (eq size 2)
                    (eq srcmode $imm_mode)
                    (dregp dstmode)
                    (eq srcext1 (sign-word srcext2))
                    (eq srcext2 (lap-sign-extend-byte srcext2)))
               (lap-gen (%ilogior #o70000              ;moveq #val,Dn
                          (%ilsl 9 dstmode)
                          (%ilogand2 #xFF srcext2))))
              ((and (eq size 2)
                    (eq srcmode $imm_mode)
                    (eq dstmode $spush_mode)
                    (eq srcext1 (sign-word srcext2)))
               (lap-gen #o44170 srcext2))              ;pea val.w
              ((eq dstmode $lisploc_mode)
               (lap-gen-moveloc
                (if (eq size 0) #o10000 (if (eq size 1) #o30000 #o20000))
                srcmode srcext1 srcext2 dstext1))
              (t
               (lap-instr-gen
                (%ilogior
                  (if (eq size 0) #o10000 (if (eq size 1) #o30000 #o20000))
                  (%ilsl 9 (%ilogand2 $reg_mask dstmode))
                  (%ilsl 3 (%ilogand2 $mode_mask dstmode)))
                srcmode
                srcext1
                srcext2)
               (lap-gen dstext1 dstext2)))))))

(deflapgen move16 (src dst)
  ;Second cut: MOVE16 (An)+, (An)+
  (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
    (declare (ignore srcext1 srcext2))
    (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
      (declare (ignore dstext1 dstext2))
      (let ((src-mode (%ilogand2 $mode_mask srcmode))
            (dst-mode (%ilogand2 $mode_mask dstmode)))
        ;(format t "src/mode: #o~O,  dst/mode: #o~O,  src's mode: #o~O,  dst's mode: #o~O~%"
        ;        srcmode dstmode src-mode dst-mode)
        (cond ((and (eq src-mode $pop_mode) (eq dst-mode $pop_mode))
               ;Post-increment source and destination:
               (lap-gen (%ilogior #o173040
                          (%ilogand2 $reg_mask srcmode)))
               (lap-gen (%ilogior #o100000
                          (%ilsl 12 (%ilogand2 $reg_mask dstmode)))))
              ((or (and (or (eq src-mode $ind_mode) (eq src-mode $pop_mode))
                        (eq dstmode $abs.l_mode))
                   (and (or (eq dst-mode $ind_mode) (eq dst-mode $pop_mode))
                        (eq srcmode $abs.l_mode)))
               (lap-error "MOVE16 Abs Long Addr Src/Dst not yet implemented."))
              (t (lap-error "MOVE16 does not support one or both of these operand modes.")))))))

(deflapgen add (src dst)
  (lap-addsub src dst #xD000 #o3000 #o50000 #o50400))
(deflapgen sub (src dst)
  (lap-addsub src dst #x9000 #o2000 #o50400 #o50000))

(defun lap-addsub (src dst instr imm posq negq &aux (size (cur-size 6)))
   (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
     (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
       (when (eq srcmode $imm_mode)
          (when (and (setq src (if (neq size #o200) (setq src srcext1)
                                   (if (eq srcext1 0) (setq src srcext2))))
                     (neq src 0)
                     (%i<= src 8))
             (return-from lap-addsub
               (lap-instr-gen (%ilogior posq ;addq #n,dst
                                        (%ilsl 9 (%ilogand2 7 src))
                                        size)
                              dstmode
                              dstext1
                              dstext2)))
          (when (if (eq size 0) (%i<= #xF8 (setq src srcext1))
                   (if (eq size #o100) (%i<= #xFFF8 (setq src srcext1))
                      (if (eq srcext1 #xFFFF) (%i<= #xFFF8 (setq src srcext2)))))
             (return-from lap-addsub
               (lap-instr-gen (%ilogior negq ;subq #n,dst
                                        (%ilsl 9 (%ilogand2 7 (%i- 0 src)))
                                        size)
                              dstmode
                              dstext1
                              dstext2))))
       (cond ((regp dstmode) ;add src,Rn
              (lap-instr-gen (%ilogior instr
                                       (%ilsl 9 (%ilogand dstmode 7))
                                       (if (dregp dstmode) size
                                           (if (eq size #o100) #o300 #o700)))
                             srcmode srcext1 srcext2))
             ((or (eq srcmode $imm_mode) (eq srcmode $lispimm_mode))
              (lap-imminstr-gen (%ilogior imm size)
                                srcmode srcext1 srcext2 dstmode dstext1 dstext2))
             ((dregp srcmode) ;add Dn,dst
              (lap-instr-gen (%ilogior instr (%ilsl 9 srcmode) (%i+ size #o400))
                             dstmode
                             dstext1
                             dstext2))
             (t (lap-error))))))

(deflapgen and (src dst) (lap-andor src dst t))
(deflapgen or (src dst) (lap-andor src dst nil))

(defun lap-andor (src dst andp &aux (size (cur-size 6)))
  (if (or (eq dst 'sr) (eq dst 'ccr))
    (lap-andor-sr-ccr src dst andp)
    (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
      (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
        (cond ((dregp dstmode) ;and src,Dn
               (when (aregp srcmode) (lap-error))
               (lap-instr-gen (%ilogior (if andp #o140000 #o100000)
                                        (%ilsl 9 dstmode)
                                        size)
                              srcmode srcext1 srcext2))
              ((or (eq srcmode $imm_mode) (eq srcmode $lispimm_mode))
               (lap-imminstr-gen 
                (%ilogior (if andp #o1000 0) size)
                srcmode srcext1 srcext2 dstmode dstext1 dstext2))
              ((dregp srcmode) ;and Dn,dst
               (when (regp dstmode) (lap-error))
               (lap-instr-gen (%ilogior (if andp #o140000 #o100000)
                                        (%ilsl 9 srcmode)
                                        (%i+ size #o400))
                              dstmode
                              dstext1
                              dstext2))
              (t (lap-error)))))))

(defun lap-andor-sr-ccr (src dst andp)
  (unless (and (listp src) (eq (car src) '$) (fixnump (setq src (cadr src))))
    (lap-error))
  (cond ((eq dst 'sr)
         (unless (<= 0 src #xffff) (lap-error))
         (lap-gen (if andp #x027c #x007c) src))
        ((eq dst 'ccr)
         (unless (<= 0 src #xff) (lap-error))
         (lap-gen (if andp #x023c #x003c) src))
        (t (lap-error))))

(deflapgen cmp (src dst &aux (size (cur-size 6)))
   (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
      (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
        (cond ((regp dstmode)
               (lap-instr-gen (%ilogior #o130000
                                        (%ilsl 9 (%ilogand2 $reg_mask dstmode))
                                        (if (dregp dstmode) size
                                            (if (eq size #o100) #o300 #o700)))
                              srcmode srcext1 srcext2))
              ((or (eq srcmode $imm_mode) (eq srcmode $lispimm_mode))
               (lap-imminstr-gen (%ilogior #o06000 size)
                                 srcmode srcext1 srcext2 dstmode dstext1 dstext2))
              ((and (eq (%ilogand2 $mode_mask srcmode) $pop_mode)
                    (eq (%ilogand2 $mode_mask dstmode) $pop_mode))
               (lap-gen (%ilogior #o130410
                                  (%ilsl 9 (%ilogand2 $reg_mask dstmode))
                                  size
                                  (%ilogand2 $reg_mask srcmode))))
              (t (lap-error))))))

(deflapgen link (src dst)
  (let ((areg (lap-areg-op src)))
    (multiple-value-bind (dstmode dstext1 dstext2) (lap-std-operand dst)
      (declare (ignore dstext1))
      (unless (eq dstmode $imm_mode)
        (lap-error "Bad destination operand" dst))
      (lap-gen (%ilogior2 #o47120 areg) dstext2))))

(deflapgen unlk (areg)
  (lap-gen (%ilogior2 #o47130 (lap-areg-op areg))))

(deflapgen eor (src dst &aux (size6 (cur-size 6)))
  (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
    (multiple-value-bind (dstmode dstext1 dstext2) (lap-dest-op dst)
      (when (aregp dstmode) (lap-error))
      (cond ((dregp srcmode)
             (lap-instr-gen (%ilogior #o130400
                                      (%ilsl 9 srcmode)
                                      size6)
                            dstmode dstext1 dstext2))
            ((or (eq srcmode $imm_mode) (eq srcmode $lispimm_mode))
             (lap-imminstr-gen (%ilogior #o5000 size6)
                               srcmode srcext1 srcext2 dstmode dstext1 dstext2))
            (t (lap-error))))))

(deflapgen addx (src dst)
  (lap-addsubx src dst #o150400))
(deflapgen subx (src dst)
  (lap-addsubx src dst #o110400))

(defun lap-addsubx (src dst instr &aux (size6 (cur-size 6)))
  (setq src (lap-source-op src) dst (lap-dest-op dst))
  (cond ((and (dregp src) (dregp dst))
         (lap-gen (%ilogior instr (%ilsl 9 dst) size6 src)))
        ((and (eq (%ilogand2 $mode_mask src) $push_mode)
              (eq (%ilogand2 $mode_mask dst) $push_mode))
         (lap-gen (%ilogior instr (%ilsl 9 (%ilogand2 $reg_mask dst))
                                  size6
                                  (%ilogand2 $reg_mask src)
                                  #o10)))
        (t (lap-error))))

(deflapgen exg (rx ry &aux x)
  (when (and *lap-cur-size* (neq *lap-cur-size* 2)) (lap-error))
  (setq rx (lap-reg-op rx) ry (lap-reg-op ry))
  (if (dregp rx)
      (if (dregp ry) (setq x #o140500)
          (setq x #o140610 ry (%ilogand2 $reg_mask ry)))
      (progn
       (setq rx (%ilogand2 $reg_mask rx))
       (if (dregp ry) (setq x rx rx ry ry x x #o140610)
          (setq x #o140510 ry (%ilogand2 $reg_mask ry)))))
  (lap-gen (%ilogior x (%ilsl 9 rx) ry)))

(deflapgen ext (dn &aux (size6 (cur-size 6)))
   (when (eq size6 0) (lap-error))
   (lap-gen (%ilogior #o44000 (%i+ size6 #o100) (lap-dreg-op dn))))

(deflapgen swap (dn)
  (when (and *lap-cur-size* (neq *lap-cur-size* 1)) (lap-error))
  (lap-gen (%ilogior #o44100 (lap-dreg-op dn))))

(deflapgen illegal () (lap-gen #o45374))
(deflapgen nop () (lap-gen #o47161))
(deflapgen rts () (lap-gen #o47165))

(deflapgen negx (op) (lap-arith1 op #o40000))
(deflapgen clr (op)  (lap-arith1 op #o41000))
(deflapgen neg (op)  (lap-arith1 op #o42000))
(deflapgen not (op)  (lap-arith1 op #o43000))
(deflapgen tst (op)  (lap-arith1 op #o45000))

(defun lap-arith1 (op instr &aux (size (cur-size 6)))
  (multiple-value-bind (mode ext1 ext2) (lap-dest-op op)
     (when (or (aregp mode)
               (and (neq size #o200) (%i> mode $imm_mode)))
       (lap-error))
     (lap-instr-gen (%ilogior instr size) mode ext1 ext2)))

; The syntax for the long forms of these is:
; (muls.l src Dl)             - src * Dl -> Dl
; (muls.l src (Dh Dl))        - src * Dl -> Dh:Dl
; (divs.l src Dq)             - (floor Dq src) -> Dq
; (divs.l src (Dr Dq))        - (floor Dr:Dq src) -> Dq (quotient) & Dr (remainder)
; (divsl.l src Dq)            - same as (divs.l src Dq)
; (divsl.l src (Dr Dq))       - (floor Dq src) -> Dq (quotient) & Dr (remainder)
(deflapgen divs (src dst)
  (lap-muldiv src dst #o100700))
(deflapgen divu (src dst)
  (lap-muldiv src dst #o100300))
(deflapgen muls (src dst)
  (lap-muldiv src dst #o140700))
(deflapgen mulu (src dst)
  (lap-muldiv src dst #o140300))
(deflapgen divsl (src dst)
  (unless (eq *lap-cur-size* 2) (lap-error))
  (lap-muldiv src dst #o100700 0))
(deflapgen divul (src dst)
  (unless (eq *lap-cur-size* 2) (lap-error))
  (lap-muldiv src dst #o100300 0))

(defun lap-muldiv (src dst instr &optional sizebit)
  (when (and *lap-cur-size* (eq *lap-cur-size* 0)) (lap-error))
  (multiple-value-bind (srcmode srcext1 srcext2) (lap-source-op src)
    (if (eq *lap-cur-size* 2)
      (progn
        (let ((signed-bit (if (logbitp 8 instr) #o4000 0))
              (div-bit (if (logbitp 14 instr) 0 #o100))
              dh dl)
          (if (listp dst)
            (setq dl (lap-dreg-op (cadr dst))
                  dh (lap-dreg-op (car dst))
                  sizebit (or sizebit #o2000))          ; 32x32->64
            (setq dl (lap-dreg-op dst)
                  dh dl
                  sizebit (or sizebit 0)))      ; 32x32->32
          (when (or (aregp dh) (aregp dl)) (lap-error))
          (lap-gen (+ #o46000 div-bit srcmode)
                   (+ signed-bit sizebit (ash dl 12) dh)
                   srcext1 
                   srcext2)))
      (progn 
        (when (aregp srcmode) (lap-error))
        (lap-instr-gen (%ilogior instr (%ilsl 9 (lap-dreg-op dst)))
                       srcmode srcext1 srcext2)))))

(deflapgen asr (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160000 #o160300))
(deflapgen asl (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160400 #o160700))
(deflapgen lsr (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160010 #o161300))
(deflapgen lsl (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160410 #o161700))
(deflapgen roxr (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160020 #o162300))
(deflapgen roxl (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160420 #o162700))
(deflapgen ror (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160030 #o163300))
(deflapgen rol (count &optional (loc () loc-p))
   (lap-shift-instr count loc loc-p #o160430 #o163700))

(defun lap-shift-instr (count loc loc-p instr minstr &aux (size6 (cur-size 6)))
   (if (not loc-p)
       (let ((mode (lap-dest-op count)))
          (if (dregp mode)
              (lap-gen (%ilogior instr #o1000 size6 mode))
             (if (and (eq size6 #o100) (%i<= mode $imm_mode))
               (lap-gen (%ilogior minstr mode))
               (lap-error "bad operation size"))))
       (multiple-value-bind (mode ext1 ext2) (lap-dest-op loc)
          (multiple-value-bind (count reg-p) (lap-count-op count 1 8)
             (cond ((dregp mode)
                    (lap-gen (%ilogior instr
                                       (%ilsl 9 (%ilogand count 7))
                                       size6
                                       (if reg-p #o40 0)
                                       mode)))
                   ((and (not reg-p) (eq count 1) (eq size6 #o100) (%i<= mode $imm_mode))
                    (lap-instr-gen minstr mode ext1 ext2))
                   (t (lap-error)))))))

(deflapgen bchg (bit dst)
  (lap-bit-instr bit dst #o100))
(deflapgen bclr (bit dst)
  (lap-bit-instr bit dst #o200))
(deflapgen bset (bit dst)
  (lap-bit-instr bit dst #o300))
(deflapgen btst (bit dst)
  (lap-bit-instr bit dst #o000))

(defun lap-bit-instr (bit dst instr &aux (size *lap-cur-size*))
  (multiple-value-bind (mode ext1 ext2) (lap-dest-op dst (eql instr 0))
    (when (aregp mode) (lap-error))
    (if (dregp mode)
      (progn
        (unless size (setq size 2))
        (unless (eq size 2) (lap-error)))
      (unless size (setq size 0)))
    (multiple-value-bind (bit reg-p)
                         (lap-count-op bit 0 (%i- (%ilsl size 8) 1))
      (if (and (not (dregp mode)) (not reg-p))
        ;Fake a btst.l/btst.w memory instruction, by modifying the dest offset.
        (let ((offset (%i- (%i- (%ilsl size 1) 1) (%ilsr 3 bit))))
          (setq bit (%ilogand bit 7))
          (unless (eq offset 0)
            (cond ((eq (%ilogand mode $mode_mask) $ind_mode)
                   (setq mode (%ilogior $rel_mode (%ilogand $reg_mask mode))
                         ext1 offset))
                  ((eq (%ilogand mode $mode_mask) $rel_mode)
                   (setq ext1 (lap-word (%i+ (%word-to-int ext1) offset)))
                   (when (eq ext1 0)
                     (setq mode (%ilogior $ind_mode (%ilogand $reg_mask mode))
                           ext1 nil)))
                  ((eq (%ilogand mode $mode_mask) $idx_mode)
                   (setq ext1 (%ilogior (%ilogand #xFF00 ext1)
                                        (lap-byte (%i+ (%byte-to-int ext1)
                                                       offset)))))
                  ((eq mode $abs.w_mode)
                   (setq ext1 (lap-word (%i+ (%word-to-int ext1) offset))))
                  ((eq mode $abs.l_mode)
                   (setq ext1 (%i+ ext1 offset))
                   (when (%i>= ext1 #x10000)
                     (setq ext1 (%i- ext1 #x10000)
                           ext2 (lap-word (%i+ (%word-to-int ext2) 1)))))
                  (t (lap-error)))))
        (when (%i> mode $imm_mode)
          (lap-error)))
      (if reg-p
        (progn
          (when (and (eql mode $imm_mode) ext2)
            (setq ext1 ext2 ext2 nil))
          (lap-instr-gen (%ilogior instr #o400 (%ilsl 9 bit)) mode ext1 ext2))
        (lap-imminstr-gen (%ilogior instr #o4000)
                          $imm_mode bit nil
                          mode ext1 ext2)))))

(deflapgen bftst (ea offset width)
  (lap-bitfield-instr #o164300 ea offset width))

(deflapgen bfextu (ea offset width dreg)
  (lap-bitfield-instr #o164700 ea offset width dreg))

(deflapgen bfchg (ea offset width)
  (lap-bitfield-instr #o165300 ea offset width))

(deflapgen bfexts (ea offset width dreg)
  (lap-bitfield-instr #o165700 ea offset width dreg))

(deflapgen bfclr (ea offset width)
  (lap-bitfield-instr #o166300 ea offset width))

(deflapgen bfffo (ea offset width dreg)
  (lap-bitfield-instr #o166700 ea offset width dreg))

(deflapgen bfset (ea offset width)
  (lap-bitfield-instr #o167300 ea offset width))

(deflapgen bfins (dreg offset width ea)
  (lap-bitfield-instr #o167700 ea offset width dreg))

(defun lap-bitfield-instr (base ea offset width &optional (reg nil reg-p))
  (multiple-value-bind (widthval width-reg-p) (lap-count-op width 1 32)
    (multiple-value-bind (offsetval offset-reg-p) (lap-count-op offset 0 31)
      (multiple-value-bind (mode ext1 ext2) (lap-std-operand ea)
        (lap-gen (%ilogior mode base)
                 (%ilogior 
                   (if reg-p (%ilsl 12 (lap-dreg-op reg)) 0)
                   (if offset-reg-p (%ilsl 11 1) 0)
                   (%ilsl 6 offsetval)
                   (if width-reg-p (%ilsl 5 1) 0)
                   (%ilogand 31 widthval))
                 ext1
                 ext2)))))

(deflapgen chk (src dst)
  (when (and *lap-cur-size* (neq *lap-cur-size* 1)) (lap-error))
  (multiple-value-bind (mode ext1 ext2) (lap-source-op src)
    (when (aregp mode) (lap-error))
    (lap-instr-gen (%ilogior #o40600 (%ilsl 9 (lap-dreg-op dst))) mode ext1 ext2)))

(deflapgen lea (label areg)
    (lap-addrinstr label (%ilogior #o40700 (%ilsl 9 (lap-areg-op areg)))))

(deflapgen pea (label)
   (lap-addrinstr label #o44100))

(deflapgen jsr (label)
   (lap-addrinstr label #o47200))

(deflapgen jmp (label)
   (lap-addrinstr label #o47300))

(defun lap-addrinstr (label instr &aux mm)
  (multiple-value-bind (mode ext1 ext2) (lap-source-op label)
    (setq mm (%ilogand2 $mode_mask mode))
    (when (or *lap-cur-size*
              (regp mode) (eq mode $lispimm_mode) (eq mode $imm_mode)
              (eq mm $push_mode) (eq mm $pop_mode))
      (lap-error))
    (setq *lap-cur-size* 2)
    (lap-instr-gen instr mode ext1 ext2)))

(deflapgen st (loc) (lap-scc loc 't))
(deflapgen sf (loc)  (lap-scc loc 'f))
(deflapgen shi (loc) (lap-scc loc 'hi))
(deflapgen sls (loc) (lap-scc loc 'ls))
(deflapgen scc (loc) (lap-scc loc 'cc))
(deflapgen scs (loc) (lap-scc loc 'cs))
(deflapgen sne (loc) (lap-scc loc 'ne))
(deflapgen seq (loc) (lap-scc loc 'eq))
(deflapgen svc (loc) (lap-scc loc 'vc))
(deflapgen svs (loc) (lap-scc loc 'vs))
(deflapgen spl (loc) (lap-scc loc 'pl))
(deflapgen smi (loc) (lap-scc loc 'mi))
(deflapgen sge (loc) (lap-scc loc 'ge))
(deflapgen slt (loc) (lap-scc loc 'lt))
(deflapgen sgt (loc) (lap-scc loc 'gt))
(deflapgen sle (loc) (lap-scc loc 'le))

(deflapgen .scc (cc loc) (lap-scc loc cc))

(deflapgen bra (label) (lap-bcc label 't))
(deflapgen bsr (label) (lap-bcc label 'f))
(deflapgen bhi (label) (lap-bcc label 'hi))
(deflapgen bls (label) (lap-bcc label 'ls))
(deflapgen bcc (label) (lap-bcc label 'cc))
(deflapgen bcs (label) (lap-bcc label 'cs))
(deflapgen bne (label) (lap-bcc label 'ne))
(deflapgen beq (label) (lap-bcc label 'eq))
(deflapgen bvc (label) (lap-bcc label 'vc))
(deflapgen bvs (label) (lap-bcc label 'vs))
(deflapgen bpl (label) (lap-bcc label 'pl))
(deflapgen bmi (label) (lap-bcc label 'mi))
(deflapgen bge (label) (lap-bcc label 'ge))
(deflapgen blt (label) (lap-bcc label 'lt))
(deflapgen bgt (label) (lap-bcc label 'gt))
(deflapgen ble (label) (lap-bcc label 'le))

(deflapgen .bcc (cc label) (lap-bcc label cc))

(deflapgen dbt  (reg label) (lap-dbcc reg label 't))  ;An expensive noop?
(deflapgen dbf  (reg label) (lap-dbcc reg label 'f))
(deflapgen dbhi (reg label) (lap-dbcc reg label 'hi))
(deflapgen dbls (reg label) (lap-dbcc reg label 'ls))
(deflapgen dbcc (reg label) (lap-dbcc reg label 'cc))
(deflapgen dbcs (reg label) (lap-dbcc reg label 'cs))
(deflapgen dbne (reg label) (lap-dbcc reg label 'ne))
(deflapgen dbeq (reg label) (lap-dbcc reg label 'eq))
(deflapgen dbvc (reg label) (lap-dbcc reg label 'vc))
(deflapgen dbvs (reg label) (lap-dbcc reg label 'vs))
(deflapgen dbpl (reg label) (lap-dbcc reg label 'pl))
(deflapgen dbmi (reg label) (lap-dbcc reg label 'mi))
(deflapgen dbge (reg label) (lap-dbcc reg label 'ge))
(deflapgen dblt (reg label) (lap-dbcc reg label 'lt))
(deflapgen dbgt (reg label) (lap-dbcc reg label 'gt))
(deflapgen dble (reg label) (lap-dbcc reg label 'le))

(deflapgen .dbcc (cc reg label) (lap-dbcc reg label cc))

(defparameter *lap-cc*
              '((t . 0) (f . 1) (hi . 2) (gtu . 2) (ls . 3) (leu . 3)
                (cc . 4) (geu . 4) (cs . 5) (ltu . 5) (ne . 6) (eq . 7)
                (vc . 8) (vs . 9) (pl . 10) (mi . 11)
                (ge . 12) (lt . 13) (gt . 14) (le . 15)))

(defun lap-scc (loc cc)
  (when (and *lap-cur-size* (neq *lap-cur-size* 0)) (lap-error))
  (unless (setq cc (%cdr (assq cc *lap-cc*))) (lap-error))
  (setq *lap-cur-size* 0)
  (multiple-value-bind (mode ext1 ext2) (lap-dest-op loc)
    (when (%i> mode $imm_mode) (lap-error))
    (lap-instr-gen (%ilogior #x50C0 (%ilsl 8 cc)) mode ext1 ext2)))

(defun lap-bcc (label cc &aux instr)
  (when *lap-cur-size* (lap-error))
  (unless (setq cc (%cdr (assq cc *lap-cc*))) (lap-error))
  (setq instr (%ilogior #x6000 (%ilsl 8 cc)))
  (when (or (symbolp label) (fixnump label)) (setq label (list '^ label)))
  (multiple-value-bind (mode ext1 ext2) (lap-std-operand label)
     (cond ((eq mode $pcrel_mode)
            (unless (and (eq ext1 0) (neq instr #x6100))
              (if (and (%i< (integer-length ext1) 8) (neq ext1 0))
                (lap-gen (%ilogior cc (%ilogand2 #xFF ext1)))
                (lap-gen instr ext1))))
           ((eq mode $label_ref_mode)
            (lap-gen (%ilogior2 #x6000 (%ilsl 8 cc)))
            (lap-gen-labref ext1 ext2))
           (t (lap-error)))))

(defun lap-dbcc (reg label cc)
  (when (and *lap-cur-size* (neq *lap-cur-size* 1)) (lap-error))
  (unless (setq cc (%cdr (assq cc *lap-cc*))) (lap-error))
  (setq cc (%ilogior #x50C8 (%ilsl 8 cc) (lap-dreg-op reg)))
  (when (or (symbolp label) (fixnump label)) (setq label (list '^ label)))
  (multiple-value-bind (mode ext1 ext2) (lap-std-operand label)
     (cond ((eq mode $pcrel_mode)
            (lap-gen cc ext1))
           ((eq mode $label_ref_mode)
            (lap-gen cc)
            (lap-gen-labref ext1 ext2))
           (t (lap-error)))))

(deflapgen movem (src dst &aux (size6 (cur-size 6)))
  (when (eq size6 0) (lap-error))
  (setq size6 (%ilogior #o44000 (%i+ size6 #o100)))
  (multiple-value-bind (dstmode dstext1 dstext2) (lap-std-operand dst)
    (if (eq dstmode $reg_list_mode)
      (multiple-value-bind (srcmode srcext1 srcext2) (lap-std-operand src)
        (setq size6 (%ilogior size6 #o2000))
        (cond ((eq srcmode $label_ref_mode)
               (let ((mask (lap-register-mask dstext1 $pcrel_mode)))
                 (when (eq (%ilogand mask #xF0FF) #x6000)
                   ;Could be confused with a branch...
                   ;This is restoring a6/a5 but not a7 or a4, and no data regs.
                   ;Strange but true.
                   (lap-error "Implementation restriction - cannot restore this set of registers pc-relative"))
                 (lap-gen (%ilogior size6 $pcrel_mode) mask)
                 (lap-gen-labref srcext1 srcext2)))
              ((and srcmode
                    (%i< srcmode $imm_mode)
                    (not (regp srcmode))
                    (not (eq $push_mode (%ilogand $mode_mask srcmode))))
               (lap-gen (%ilogior size6 srcmode)
                        (lap-register-mask dstext1 srcmode)
                        srcext1
                        srcext2))
              (t (lap-error "Bad source operand ~S" src))))
      (multiple-value-bind (srcmode srcext1) (lap-std-operand src)
        (unless (eq srcmode $reg_list_mode) (lap-error))
        (unless (and dstmode (not (regp dstmode)) (%i< dstmode #o72)
                     (not (eq $pop_mode (%ilogand $mode_mask dstmode))))
          (lap-error "Bad destination operand ~S" dst))
        (lap-gen (%ilogior size6 dstmode)
                 (lap-register-mask srcext1 dstmode)
                 dstext1
                 dstext2)))))

(deflapgen trapv ()
  (lap-gen #x4e76))

(defun lap-register-mask (vect mode &aux reg (mask 0))
  (setq mode (eq $push_mode (%ilogand $mode_mask mode)))
  (if (symbolp vect)
    (if (setq reg (lap-std-reg vect))
      (%ilsl (if mode (%i- 15 reg) reg) 1)
      (lap-error "Invalid register ~S" vect))
    (dotimes (i (length vect) mask)
      (declare (fixnum i))
      (unless (setq reg (lap-std-reg (svref vect i)))
        ;Should allow "A0-A3"
        (lap-error "Invalid register list ~S" vect))
      (setq mask (%ilogior mask (%ilsl (if mode (%i- 15 reg) reg) 1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun lap-dreg-op-p (op)
  (if (dregp (setq op (lap-std-operand op)))
    op))

(defun lap-areg-op-p (op)
  (if (and (setq op (lap-std-operand op)) (aregp op))
    op))

(defun lap-reg-op-p (op)
  (if (and (setq op (lap-std-operand op)) (regp op))
    op))

(defun lap-dreg-op (op)
  (or (lap-dreg-op-p op) (lap-error)))

(defun lap-areg-op (op)
  (unless (setq op (lap-areg-op-p op)) (lap-error))
  (%ilogand2 $reg_mask op))

(defun lap-reg-op (op)
  (or (lap-reg-op-p op) (lap-error)))

(defun lap-freg-op-p (op)
  (multiple-value-bind (mode val) (lap-std-operand op)
    (when (eq mode $fpreg_mode) val)))

(defun lap-freg-op (op)
  (or (lap-freg-op-p op) (lap-error "~s must name a floating-point register" op)))

(defun lap-count-op (op min max) ;Small count or register
   (unless (fixnump op)
      (multiple-value-bind (mode ext1 ext2) (lap-std-operand op)
         (when (and mode (dregp mode))
           (return-from lap-count-op (values mode t)))
         (unless (and (eq $imm_mode mode) (eq ext1 (sign-word ext2)))
             (lap-error "Bad count operand ~S" op))
         (setq op (if (%izerop ext1) ext2 (%i- ext2 #x10000)))))
   (when (or (%i< op min) (%i< max op))
     (lap-error "Count out of range ~S" op))
   (values op nil))

(defun lap-byte-op (op) ;small (word) count
  (multiple-value-bind (mode ext1 ext2) (lap-std-operand op)
    (if mode
      (when (and (eq $imm_mode mode) (eq ext1 (sign-word ext2)))
        (lap-byte (%word-to-int ext2)))
      (lap-byte (lap-abs-val op)))))

(defun lap-source-op (op)
   (multiple-value-bind (mode ext1 ext2) (lap-std-operand op)
     (cond ((and (eq mode $imm_mode) (neq *lap-cur-size* 2))
            (when (eq *lap-cur-size* 0) (setq ext2 (%ilogand2 ext2 #xFF)))
            (values mode ext2))
           ((or (null mode)
                (and (%i>= mode #o77) (neq mode $label_ref_mode))
                (and (eq *lap-cur-size* 0) (aregp mode)))
            (lap-error "Bad source operand ~S" op))
           (t (values mode ext1 ext2)))))

(defun lap-dest-op (op &optional imm-ok)
   (multiple-value-bind (mode ext1 ext2) (lap-std-operand op)
     (unless (and mode
                  (or (eq mode $lisploc_mode)
                      (and imm-ok (eq mode $imm_mode))
                      (%i< mode #o72))
                  (or (neq *lap-cur-size* 0) (not (aregp mode))))
         (lap-error "Bad destination operand ~S" op))
     (values mode ext1 ext2)))

; All operand parsing, even the simplest, should go through here, so that
; operand macros get expanded.
(defun lap-std-operand (exp &aux op name len)
  ;Accepts REG, @AREG, -@AREG, AREG@+,
  ;        ([AREG or PC] [REG[.L or .W] or (REG L) or (REG W)] [abs-exp]),
  ;        (@[L or W] abs-exp [abs-exp]) ($ abs-exp [abs-exp]) (quote lisp-form)
  ;        (^ label [abs-exp]) #(register list) (special lisp-form)
  ;        (function lisp-form)  (-@ AREG)  (@+ AREG)
  ; The abs-exp is any lisp expression, which must evaluate to a fixnum or char.
  (cond ((symbolp exp)
         (when (setq op (lap-std-reg exp))
            (return-from lap-std-operand op))
         (when (setq op (%cdr (assq exp *lap-fpregs*)))
           (return-from lap-std-operand (values $fpreg_mode op)))
         (setq name (symbol-name exp) len (length name))
         (cond ((eq len 0) nil)
               ((and (eq (schar name 0) #\@)
                     (setq op (assq (%subsym exp 1 len) *lap-aregs*)))
                (%i+ (%cdr op) $ind_mode))
               ((and (> len 1)
                     (eq (schar name (%i- len 1)) #\+)
                     (eq (schar name (%i- len 2)) #\@)
                     (setq op (assq (%subsym exp 0 (%i- len 2)) *lap-aregs*)))
                (%i+ (%cdr op) $pop_mode))
               ((and (> len 1)
                     (eq (schar name 0) #\-)
                     (eq (schar name 1) #\@)
                     (setq op (assq (%subsym exp 2 len) *lap-aregs*)))
                (%i+ (%cdr op) $push_mode))
               (t nil)))
        ((simple-vector-p exp)
         (unless (%izerop (length exp))
           (values
            (if (lap-std-reg (svref exp 0)) $reg_list_mode $fpreg_list_mode)
            exp)))
        ((or (atom exp)
             (not (symbolp (setq name (%car exp))))) nil)
        ((setq op (assq name *lap-aregs*))
         (lap-indirect-operand (%cdr op) (%cdr exp)))
        ((eq name 'pc)
         (lap-indirect-operand nil (%cdr exp)))
        ((eq name '-@)
         (and (consp (%cdr exp))
              (null (%cddr exp))
              (setq op (assq (%cadr exp) *lap-aregs*))
              (%i+ (%cdr op) $push_mode)))
        ((eq name '@+)
         (and (consp (%cdr exp))
              (null (%cddr exp))
              (setq op (assq (%cadr exp) *lap-aregs*))
              (%i+ (%cdr op) $pop_mode)))
        ((memq name '(@ @L @W))
         (multiple-value-bind (hi lo) (lap-long-arg (%cdr exp))
           (cond ((or (eq name '@L) (neq hi (sign-word lo)))
                  (when (eq name '@W)
                    (lap-error "Address ~S too large for @W" exp))
                  (values $abs.l_mode hi lo))
                 (t (values $abs.w_mode lo)))))
        ((eq name '$)
         (multiple-value-bind (hi lo) (lap-long-arg (%cdr exp))
           (values $imm_mode hi lo)))
        ((or (eq name 'special)
             (eq name 'function))
         (when (and (consp (%cdr exp)) (symbolp (%cadr exp)) (null (%cddr exp)))
           (values $lisploc_mode exp)))
        ((eq name 'quote)
         (when (and (consp (%cdr exp)) (null (%cddr exp)))
           (cond ((characterp (setq exp (%cadr exp)))
                  (values $imm_mode (%char-code exp) $t_imm_char))
                 ((fixnump exp)
                  (values $imm_mode (%ilsr (- 16 $fixnumshift) exp)
                          (%ilogand #xFFFF (%ilsl $fixnumshift exp))))
                 ((typep exp 'short-float)
                  (setq exp (%address-of exp))
                  (values $imm_mode (ash exp -16) (logand exp #xffff)))
                 (t (values $lispimm_mode exp)))))
        ((eq name '^)
         (when (consp (%cdr exp))
           (values $label_ref_mode (%cadr exp)
                   (if (%cddr exp) (lap-word (lap-abs-arg (%cddr exp))) 0))))
        ((setq name (gethash name *lapops*))
         (lap-std-operand (apply name (%cdr exp))))
        ))

(defun lap-indirect-operand (reg args &aux name s len op)
  (when (or (and (symbolp (setq name (car args)))
                 (or (setq op (lap-std-reg name))
                     (progn
                       (setq s (symbol-name name) len (length s))
                       (and (%i>= len 2)
                            (eq (schar s (%i- len 2)) #\.)
                            (or (eq (setq s (schar s (%i- len 1))) #\L) (eq s #\W))
                            (setq op (lap-std-reg (%subsym name 0 (%i- len 2))))))))
            (and (consp name)
                 (eq 2 (list-length name))
                 (setq op (lap-std-reg (%car name)))
                 (setq s (%cdr (assq (%cadr name) '((L . #\L) (w . #\W)))))))
    (return-from lap-indirect-operand
       (values (if (null reg) $pcidx_mode (%i+ reg $idx_mode))
               (%ilogior (%ilsl 12 op)
                         (if (eq s #\L) #x800 0)
                         (if (null (%cdr args)) 0
                             (lap-byte (lap-abs-arg (%cdr args))))))))
  (when (and (consp name)
             (eq 2 (list-length name))
             (setq op (lap-std-reg (%car name)))
             (or (eq (setq s (%cadr name)) 'l) (eq s 'w)))
    (return-from lap-indirect-operand
                 (values (if (null reg) $pcidx_mode (%i+ reg $idx_mode))
                         (%ilogior (%ilsl 12 op)
                                   (if (eq s 'l) #x800 0)
                                   (if (null (%cdr args)) 0
                                       (lap-byte (lap-abs-arg (%cdr args))))))))
  (setq args (if (null args) 0 (lap-word (lap-abs-arg args))))
  (if (and reg (eq args 0)) (%i+ reg $ind_mode)
    (values (if (null reg) $pcrel_mode (%i+ reg $rel_mode)) args)))

(defun lap-long-arg (expl &aux hi)
  (if (null expl) (lap-error "Missing arg")
   (progn
    (setq hi (lap-abs-val (car expl)))
    (if (%cdr expl)
       (values (lap-uns-word hi) (lap-uns-word (lap-abs-arg (%cdr expl))))
       (lap-long hi)))))

(defun lap-abs-arg (expl)
  (if (null expl) (lap-error "Missing arg")
   (if (cdr expl) (lap-error "Superfluous args ~S" expl)
       (lap-abs-val (%car expl)))))

(defun lap-abs-val (exp)
  (if (or (integerp exp)
          (if (characterp exp) (setq exp (%char-code exp)))
          (integerp (setq exp (eval (nx-transform exp *nx-lexical-environment*))))
          (if (typep exp 'short-float) (setq exp (%address-of exp)))
          (if (characterp exp) (setq exp (%char-code exp))))
      exp
    (error "Bad absolute expression: ~S" exp)))

(defun lap-sign-extend-byte (b)
  (if (%ilogbitp 7 (setq b (%ilogand #xff b)))
    (setq b (%ilogior #xff00 b)))
    b)

(defun lap-byte (int)
  (if (%i< (integer-length int) 8) (%ilogand2 #xFF int)
      (lap-error "Offset ~S too large for a byte" int)))

(defun lap-word (int)
  (if (%i< (integer-length int) 16) (%ilogand2 #xFFFF int)
      (lap-error "Offset ~S too large for a word" int)))

(defun lap-uns-word (int)
  (if (and (fixnump int)
           (%i<= #x-8000 int)
           (%i<= int #xFFFF))
      (%ilogand2 #xFFFF int)
      (lap-error "Offset ~S too large for a word" int)))

(defun lap-long (int)
  (if (fixnump int) (values (%ilogand2 #xFFFF (%iasr 16 int))
                            (%ilogand2 #xFFFF int))
   (if (<= #x-80000000 int #xFFFFFFFF)
       (values (%ilogand2 #xFFFF (ash int -16)) (logand #xFFFF int))
       (lap-error "Offset ~S too large for a longword" int))))

(defun lap-std-reg (exp)
  (or (%cdr (assq exp *lap-dregs*))
      (and (setq exp (assq exp *lap-aregs*))
           (%i+ (%cdr exp) 8))))

(defun %subsym (sym start end)
  (intern (%substr (symbol-name sym) start end) (symbol-package sym)))

(defun lap-error (&rest args)
  (if args
    (error "LAP: error in ~S: ~A"
           *lap-cur-instr*
           (apply #'format nil args))
    (error "LAP: error in ~S" *lap-cur-instr*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Compiler interface

(defun nx2-lap-gen-abs-immref (imm offset)
  (nx2-gen-immref (nx2-immediate-index imm) offset))

;Generate a reference to an immediate.
;Mode goes in low 6 bits of instruction, extension follows instruction.
(defun nx2-lap-gen-immref (instr imm)
  (lap-gen (%ilogior instr $imm_mode))
  (nx2-lap-gen-abs-immref imm 1))

;Generate a reference to a symbol locative.
;Mode goes in low 6 bits of instruction, extension follows instruction.
(defun nx2-lap-gen-locref (instr loc)
  (nx2-gen (%ilogior instr $abs.l_mode))
  (nx2-lap-gen-abs-immref (if (eq (car loc) 'function)
                             (nx2-symbol-entry-locative (cadr loc))
                             (nx2-symbol-value-locative (cadr loc))) 1))

;Generate a reference to a symbol locative destination with an immediate source.
;Mode goes in low 6 bits of instruction, extension follows source.
(defun nx2-lap-gen-immlocref (instr srcmode srcext1 srcext2 loc)
  (nx2-gen (%ilogior instr $abs.l_mode))
  (if (eq srcmode $lispimm_mode)
    (nx2-lap-gen-abs-immref srcext1 nil)
    (nx2-gen srcext1 srcext2))
  (nx2-lap-gen-abs-immref (if (eq (car loc) 'function)
                             (nx2-symbol-entry-locative (cadr loc))
                             (nx2-symbol-value-locative (cadr loc))) 3))

;Generate a move to a symbol locative destination.
(defun nx2-lap-gen-moveloc (instr srcmode srcext1 srcext2 loc)
  (lap-instr-gen (%ilogior instr #o1700) ;$abs.l_mode
                 srcmode srcext1 srcext2)
  (nx2-lap-gen-abs-immref (if (eq (car loc) 'function)
                             (nx2-symbol-entry-locative (cadr loc))
                             (nx2-symbol-value-locative (cadr loc)))
                           (cond ((or (eq srcmode $lisploc_mode)
                                      (eq srcmode $lispimm_mode)
                                      (and (neq srcmode $label_ref_mode) srcext1 srcext2))
                                  -3)
                                 ((or (eq srcmode $label_ref_mode) srcext1 srcext2)
                                  -2)
                                 (t -1))))

(defun nx2-get-lap-label (label)
  (declare (special *lap-labels*))
  (%cdr (or (assq label *lap-labels*)
            (%car (push (cons label (nx2-get-next-label)) *lap-labels*)))))

(defun nx2-lap-gen-label (label)
  (declare (special *nx2-labels*))
  (nx2-get-lap-label label)
  (dolist (x *lap-labels*)
    (when (eq (%car x) label)
      (if (eq -1 (aref *nx2-labels* (%cdr x)))
        (nx2-gen-label (%cdr x))
        (lap-error "Duplicate label ~s" label)))))

(defun nx2-lap-gen-labref (label offset)
  (declare (special *nx2-icode* *nx2-linkmap*))
  (when (and offset (not (%izerop offset)))
    (lap-error "Label offsets not supported now."))
  (vector-push-extend (fill-pointer *nx2-icode*) *nx2-linkmap*)
  (vector-push-extend (%ilsl $lm_bit_pcrel 1) *nx2-linkmap*)
  (nx2-gen (nx2-get-lap-label label)))

(defparameter *compiler-gen-vec* (vector (#-bccl quote #+bccl function nx2-gen)
                                         (#-bccl quote #+bccl function nx2-lap-gen-abs-immref)
                                         (#-bccl quote #+bccl function nx2-lap-gen-immref)
                                         (#-bccl quote #+bccl function nx2-lap-gen-locref)
                                         (#-bccl quote #+bccl function nx2-lap-gen-immlocref)
                                         (#-bccl quote #+bccl function nx2-lap-gen-moveloc)
                                         (#-bccl quote #+bccl function nx2-lap-gen-label)
                                         (#-bccl quote #+bccl function nx2-lap-gen-labref)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Output interface

(defvar *lap-gen-vec* *compiler-gen-vec*)

(defun lap-gen (&rest args)
  (declare (dynamic-extent args))
  (dolist (arg args)
    (when arg (funcall (%svref *lap-gen-vec* 0) arg))))

(defun lap-gen-abs-immref (imm offset)
  (funcall (%svref *lap-gen-vec* 1) imm offset))

(defun lap-gen-immref (instr imm)
  (funcall (%svref *lap-gen-vec* 2) instr imm))

(defun lap-gen-locref (instr loc)
  (funcall (%svref *lap-gen-vec* 3) instr loc))

(defun lap-gen-immlocref (instr srcmode srcext1 srcext2 loc)
  (funcall (%svref *lap-gen-vec* 4) instr srcmode srcext1 srcext2 loc))

(defun lap-gen-moveloc (instr srcmode srcext1 srcext2 loc)
  (funcall (%svref *lap-gen-vec* 5) instr srcmode srcext1 srcext2 loc))

(defun lap-gen-label (label)
  (funcall (%svref *lap-gen-vec* 6) label))

(defun lap-gen-labref (label offset)
  (funcall (%svref *lap-gen-vec* 7) label offset))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro lap-list (&body instructions)
  `',(%lap-words instructions))

(defmacro lap-vector (&body instructions)
  `',(coerce (%lap-words instructions) '(vector (signed-byte 16))))

(defun %lap-words (instructions)
  (let* ((lfun 
          (let ((*save-local-symbols* nil))
            (compile-user-function `(lambda (&lap 0) (lap ,@instructions)) nil)))
         (vec (%lfun-vector lfun))
         (attrib (lfun-attributes lfun))
         (nwords (- (uvsize vec) 1 (%lfun-vector-mapwords vec)))
         (words ())
         (numimms 0))
    (unless (%ilogbitp $lfatr-noname-bit attrib)
      (setq numimms (%i+ numimms 1) nwords (%i- nwords 2)))
    (when (%ilogbitp $lfatr-symmap-bit attrib)
      (setq numimms (%i+ numimms 1) nwords (%i- nwords 2)))
    (unless (and (eq (%count-immrefs vec) numimms)
                 (null (lfun-vector-name vec))
                 (or (eq numimms 0)
                     ; [slh 2/17/95] seems to be nil for anonymous fns
                     ;(and (%immref-p (%i- nwords 2) vec) (or ...))
                     (eq numimms 1)
                     (%immref-p nwords vec)))
      (error "Immediates not allowed"))
    (until (eq nwords 0)
      (push (uvref vec nwords) words)
      (setq nwords (%i- nwords 1)))
    words))

#|
;Not tested... Might be worth finishing it up if we ever want to be able to use
;lap without the compiler present...

(defvar *lap-words*)

(defun lapwords-immerror (&rest ignore)
  (declare (ignore ignore))
  (lap-error "Can't reference immediates"))

(defun lapwords-gen-label (label &aux def)
  (when (null (setq def (assq label *lap-labels*)))
    (push (setq def (cons label t)) *lap-labels*))
  (unless (eq (%cdr def) t)
    (lap-error "Duplicate label ~s" label))
  (%rplacd def *lap-words*))

(defun lapwords-gen-labref (label offset &aux def)
  (when (null (setq def (assq label *lap-labels*)))
    (push (setq def (cons label t)) *lap-labels*))
  (push def *lap-words*))

(defvar *lapwords-gen-vec* (vector
                            #'(lambda (word) (push word *lap-words*))
                            (#-bccl quote #+bccl function lapwords-immerror)
                            (#-bccl quote #+bccl function lapwords-immerror)
                            (#-bccl quote #+bccl function lapwords-immerror)
                            (#-bccl quote #+bccl function lapwords-immerror)
                            (#-bccl quote #+bccl function lapwords-immerror)
                            (#-bccl quote #+bccl function lapwords-gen-label)
                            (#-bccl quote #+bccl function lapwords-gen-labref)))

(defun %other-lap-words-that-meta-point-wont-lose-on (instructions)
  (let* ((*lap-labels* nil)
         (*lap-aregs* *lap-aregs*)
         (*lap-dregs* *lap-dregs*)
         (*lap-vars* nil)
         (*lap-bindings* nil)
         (*lap-vtop* 0)
         (*lap-words* ())
         (*lap-gen-vec* *lapwords-gen-vec*))
    (unwind-protect
      (dolist (instr instructions) (lap-instr instr))
      (%progvrestore *lap-bindings*))
    (dolist (label *lap-labels*)
      (when (eq (%cdr label) t)
        (lap-error "Undefined LAP label ~S" (%car label)))
      (%rplaca label nil))
    ;Find short branches.  This can certainly be done more efficiently, but
    ;I don't feel like thinking about it right now...
    (let ((found t) words w)
      (while found
        (setq found nil words *lap-words*)
        (while words
          (when (and (consp (setq w (%car words)))
                     (null (%car w))
                     (fixnump (%cadr words))
                     (eq #x6000 (%ilogand #xF000 (%cadr words)))
                     (let* ((refpos (length (%cdr words)))
                            (labpos (length (%cdr w)))
                            (offset (- labpos refpos)))
                       (and (neq offset 0) (%i< (integer-length offset) 7))))
            (%rplaca words (cons (%cadr words) (%cdr w)))
            (%rplacd words (%cddr words))
            (setq found t))
          (setq words (%cdr words)))))
    (let* ((words *lap-words*) w)
      (while words
        (when (consp (setq w (%car words)))
          (let ((offset (- (length (%cdr w)) (length (%cdr words)))))
            (if (null (%car w))
              (if (> (integer-length offset) 15)
                (lap-error "Offset too large")
                (%rplaca w (%ilogand #xFFFF (%i+ offset offset))))
              (%rplaca words (%ilogior (%car w) (%ilogand #xFF (%i+ offset offset)))))))
        (setq words (%cdr words))))
    (nreverse *lap-words*)))
|#

(defun %fpgen (opclass rx ry extension &optional (ea-mode-reg 0)  &rest ea-extension-words)
  (apply #'lap-gen 
         (%ilogior #o171000 ea-mode-reg)
         (%ilogior (%ilogand 63 extension) 
                  (%ilsl 7 (%ilogand 7 ry)) 
                  (%ilsl 10 (%ilogand 7 rx))
                  (%ilsl 13 (%ilogand 7 opclass)))
         ea-extension-words))

(provide 'lap)

) ; #-ppc-target

; End of Lap.Lisp

#|
	Change History (most recent last):
	2	12/29/94	akh	merge with d13
|# ;(do not edit past this line!!)
