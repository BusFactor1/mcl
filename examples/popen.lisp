;; POPEN.LISP;;;; POPEN - open a stream to a process that executes a BSD command in a shell.;;;; Copyright (C) 2007-2011 Terje Norderhaug <terje@in-progress.com>;; Released under Lisp Lesser GNU Public License (LLGPL) <http://opensource.franz.com/preamble.html>.;; Alternative licensing available upon request/demand.;; ;; DISCLAIMER: The user of this module should understand that executing code is a potentially hazardous ;; activity, and that many dangers and obstacles, marked or unmarked, may exist within this code.;; As a condition of your use of the module, you assume all risk of personal injury, death, or property;; loss, and all other bad things that may happen, even if caused by negligence, ignorance or stupidity.;; The author is in no way responsible, and besides, does not have "deep pockets" nor any spare change.;;;; Version: 0.2 (April 14, 2011);; Requires MacOSX 10.3 or later. Tested on MCL 5.1, MCL 5.2 and MCL 6.;;;; Email feedback and improvements to <terje@in-progress.com>.;; HISTORY;; 2007-Oct-18 v0.1 distributed to the Info-MCL mailing list.;; 2008-Aug-25 terje p-stream supports stream-untyi.;; 2008-Sep-01 terje p-stream implements stream-listen.;; 2008-Oct-08 terje p-stream implements stream-copy-until-eof.;; 2009-Jun-05 terje *kevent-polling-delay* can be set to a number for less aggressive kevent polling. ;; 2009-Jun-24 terje *open-p-streams* and popen-cleanup.;; 2009-Jun-25 terje stream-close on p-stream waits until eof before calling pclose, as the latter hangs for process termination;; 2009-Jul-25 terje uses make-kevent function instead of make-record.;; 2009-Jul-25 terje uses special kevent- accessors for 64 bit compatibility.;; 2009-Jul-26 terje use primitive polling in %socket-readable instead of kevents, as it is unlcear when to use 64bit kevent records.;; 2009-Jul-26 terje %system-fgetc has an optional eof-error-p.;; 2009-Jul-26 terje *kevent-polling-delay* renamed to *popen-polling-delay*;; 2009-Oct-19 terje signal error if popen() fails when initializing a p-stream. ;; 2009-Oct-20 terje call fflush() before popen when opening p-stream to avoid crashes when writing to stream (see BUGS note in man popen);; 2009-Oct-20 terje new stream-finish-output calls fflush() instead of doing it when opening p-stream;; 2011-Apr-14 v0.2 added to MCL 6 distribution(in-package :ccl)(export 'popen)(load (merge-pathnames ":kqueue.lisp" *loading-file-source-file*))(defvar *popen-polling-delay* 1/20  "How many seconds to wait before retrying a kevent poll (or NIL for aggressive polling)")(declare-bundle-ff %%system-fgetc "fgetc" :address fp :signed-fullword)(defun %system-fgetc (fp &optional eof-error-p)  "Obtain the next input character (if present) from the file pointer"  (let ((result (%%system-fgetc fp)))    (if (minusp result)      (when eof-error-p         (error "Failed when calling fgetc (~A)" result))      (character result))))(declare-bundle-ff %%system-fputc "fputc" :signed-fullword char :address fp :signed-fullword)(defun %system-fputc (char fp)  (let ((result (%%system-fputc (char-int char) fp)))    (when (minusp result)      (error "Failed fputc ~A (~A)" char result))    result))(declare-bundle-ff %system-fileno "fileno" :address fp :unsigned-fullword)(declare-bundle-ff %system-feof "feof" :address file :signed-fullword)(declare-bundle-ff %system-poll "poll" :address fds :unsigned-fullword nfds :unsigned-fullword timeout :signed-fullword)(declare-bundle-ff %system-fflush "fflush" :address fp :signed-fullword)(defun %socket-readable (fp &optional block)  "Return the maximum number of characters available for reading (optionally blocking until a socket has data), or NIL if all data has been read. The second value is T if there are potentially more data afterwards."  ; This implementation may return 1 even if it is not known whether more characters are available.   (let ((pollin #x001)         #+ignore (pollerr #x008)         #+ignore (pollhup #x010)         #+ignore (Pollnval #x20))     (rlet ((pollfd :pollfd :fd (%system-fileno fp) :events pollin :revents 0))       (loop           for result = (%system-poll pollfd 1 0)          for eof = (not (zerop (%system-feof fp))) ; (plusp (logand (rref pollfd :pollfd.revents) (logior pollerr)))          ; do (print-record pollfd :pollfd)          while (zerop result)          until eof          unless block          return (values 0 (not eof))          do (if *popen-polling-delay*               (sleep *popen-polling-delay*)               (suspend-current-process "ppoll"))          finally (when (plusp result)                     (return (values (unless eof 1) (not eof))))))))#+ignore(defun %socket-readable (fp &aux (q (make-instance 'kqueue)))  "Wait until a socket has data, then returns the max number of characters avaiable for reading, or NIL if the socket has closed"  ;; Note that this works differently than the listen function!  (kqueue-subscribe q                    :ident (%system-fileno fp)                    :filter $kevent-read-filter                     :flags (logior $kevent-add $kevent-oneshot #+ignore $kevent-clear #+ignore $kevent-eof)                    :fflags 0                    :data 0                    :udata (%int-to-ptr #xdeadbeef)) ;; funny value from example somewhere ;-)  ;; this is a process-wait!  (loop for result = (multiple-value-list                       (kqueue-poll q)) ;; wild consing        until (car result)        do (process-allow-schedule)        ; do (sleep 1)        finally (when (= 1 (logand $kevent-error (third result)))                  (error "Socket ~A reported an error" fp))        finally (return (let ((completed (not (zerop (logand $kevent-eof (third result)))))                              (numchars (fifth result)))                          (apply #'values                                  (unless (and completed (= numchars 0)) numchars)                                 completed                                 result)))))#+ignore ; alternative version with kevents (more efficient but more messy)(defun %socket-readable (fp &optional block)  "Waits until a socket has data (unless block is NIL), then returns the maximum number of characters available for reading, or NIL if all data has been read. The second value is T if there are potentially more data afterwards."  ;; Set block to T for efficiency, blocks for input with the equivalent of a process-wait.  ;; Note: At least in MacOSX 10.4, the system will only report once how many characters are available for reading (error?)  ;; Note: At least in MacOSX 10.4, a kqueue for a pipe may be set to $kevent-eof even if there is potentially more output, if popen with just "r". OS Error?   ;; ##rename to %socket-ready ?  ;; # Conses wildly...  (let ((q (make-instance 'kqueue)))    (unwind-protect      (loop        with kq = (slot-value q 'kq)        ; either a new record or reinitialize attributes:        for ke = (make-kevent                  :ident (%system-fileno fp)                  :filter $kevent-read-filter                  :flags (logior $kevent-add $kevent-oneshot #+ignore $kevent-clear $kevent-eof))        with result = (make-kevent)        do (with-timer ; without-interrupts - needs a semaphore?             (%kevent kq ke result))        when (= 1 (logand $kevent-error (kevent-flags result)))        do (error "Socket error ~A" (kevent-data result))        until (eql $kevent-read-filter (kevent-filter result))        when (not block)        return (values 0 T)        do (if *popen-polling-delay*             (sleep *popen-polling-delay*)             (suspend-current-process "kevent")) ; (process-allow-schedule)         finally (let ((more (zerop (logand $kevent-eof (kevent-flags result))))                      (numchars (kevent-data result)))                   (return (values                            (unless (and (not more) (= numchars 0)) numchars)                           more))))      (kqueue-close q))))(defrecord pollfd  (fd :long)  (events :short)  (revents :short))#| Alternative implementation suggested by Toomas Altosaar:(defparameter *%socket-readable-kevent-loop-counter* 0)(defparameter *%socket-readable-describe* nil);(setq *%socket-readable-describe* T)(defun %socket-readable-sleep-fn (&optional (sleep-in-ticks 3))  ;;; 2007-10-23TA added  (let* ((next-time (%tick-sum (get-tick-count) sleep-in-ticks))         (wait-fn #'(lambda () (%i> (%tick-difference (get-tick-count) (the fixnum next-time)) 0))))    (declare (dynamic-extent wait-fn))    (declare (fixnum next-time))    (process-wait "%socket-readable-sleep-fn" wait-fn)));(time (%socket-readable-sleep-fn))(defun %socket-readable (fp &optional block &aux (q (make-instance 'kqueue)))  "Waits until a socket has data, then returns the number of characters available for reading, or NIL if all data has been read. The second value is T if there are potentially more data afterwards."  ;; Set block to T for efficiency, blocks for input with the equivalent of a process-wait.  ;; Note: At least in MacOSX 10.4, the system will only report once how many characters are available for reading (error?)  (setq *%socket-readable-kevent-loop-counter* 0)  ;;; 2007-10-23TA added  (loop    with kq = (slot-value q 'kq)    with ke = (make-record kevent                          :ident (%system-fileno fp)                          :filter $kevent-read-filter                          :flags (logior $kevent-add $kevent-oneshot #+ignore $kevent-clear #+ignore $kevent-eof)                          :fflags 0                          :data 0                          :udata (%null-ptr))    with result = (make-record kevent)    do (without-interrupts        (%kevent kq ke result)        (incf *%socket-readable-kevent-loop-counter*))  ;;; 2007-10-23TA added    when (= 1 (logand $kevent-error (rref result :kevent.flags)))    do (error "Socket error ~A" (rref result :kevent.data))    until (eql $kevent-read-filter (rref result :kevent.filter))    when (not block)    return (values 0 T)    ;;; 2007-10-23TA is this what we want to do? It seems that if we are already in the scheduler, then (process-allow-schedule) does nothing.    ;; do (process-allow-schedule) ; this was giving like 180k loops!!! Burning CPU!!!    do (%socket-readable-sleep-fn) ;;; 2007-10-23TA added    finally (let ((completed (not (zerop (logand $kevent-eof (rref result :kevent.flags)))))                  (numchars (rref result :kevent.data)))              (kqueue-close q)              (when *%socket-readable-describe*                (format t "~%Exiting %socket-readable: looped ~d time~p"                        *%socket-readable-kevent-loop-counter* *%socket-readable-kevent-loop-counter*))              (return (values                       (unless (and completed (= numchars 0)) numchars)                       (not completed))))))|#(declare-bundle-ff %system-popen "popen" :address cmd :address mode :address)(defun system-popen (command)  (with-cstrs  ((read "r+")                (cmd command))    (%system-popen cmd read)))(declare-bundle-ff %system-pclose "pclose" :address fp :signed-fullword)(defun system-pclose (fp)  (%system-pclose fp))(defun execute-shell-command (command-string &key output-stream (mac-line-feeds? t))  "Executes the system command"  (let ((fp (without-interrupts (system-popen command-string))))    (unless (%null-ptr-p fp)      (unwind-protect        (flet ((%output-result (out)                (loop                 (multiple-value-bind (len more)                                      (%socket-readable fp T)                                                    (when (and len (plusp len))                     (loop                       for i below len                         for c = (without-interrupts (%system-fgetc fp))                        while c                        do (if (and mac-line-feeds? (eq c #\linefeed))                             (write-char #\newline out)                             (write-char c out))                        finally (force-output out)                        ))                   (unless more                     (return-from %output-result))                   (when (or (null len) (zerop len))                     (if *popen-polling-delay*                       (sleep *popen-polling-delay*)                       (suspend-current-process "shell")))))))          (etypecase output-stream            ((eql :ignore) ;; ignore output from process without reading it              (loop                (multiple-value-bind (numchars more)                                    (%socket-readable fp T)                 (unless more                   (return numchars)))))            (null              (with-output-to-string (out)               (%output-result out)))            (stream              (%output-result output-stream)             NIL)))        (without-interrupts          (system-pclose fp))))))#|(execute-shell-command "cal" :output-stream *debug-io*)(execute-shell-command "cal;sleep 3;ls;sleep 2" :output-stream *debug-io*) (gc)(execute-shell-command "cal;sleep 3;ls;sleep 2" :output-stream :ignore) (gc)|#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; P-STREAM(defclass p-stream (input-stream output-stream)  ((fp :initform NIL :type (or null macptr))   (command :initarg :command :type (or null string) :initform NIL)   (n :type (or null integer) :initform 0 )   (more :type boolean :initform T)   (untyic :type (or character null) :initform NIL)   (outcount :type integer :initform 0             :documentation "character written since last flush"))  (:documentation "stream to communicate with a system process executing a command"))(defloadvar *open-p-streams* ())(defun popen-cleanup ()  (do* ()       ((null *open-p-streams*))    (close (pop *open-p-streams*) :abort T)))(pushnew #'popen-cleanup *lisp-cleanup-functions* :key #'function-name :test #'eq)(defmethod initialize-instance :after ((stream p-stream) &key)  (with-slots (fp command) stream    (when command      (let ((value (without-interrupts                    #+ignore                    (%system-fflush (%null-ptr))                    (system-popen command))))        (cond         ((%null-ptr-p value)          (error "Failed to popen"))         (T          (setf fp value)          (pushnew stream *open-p-streams*)))))))(defmethod stream-close :after ((stream p-stream))  (unwind-protect    (with-slots (fp) stream      (when fp        (let ((fp (prog1 fp (setf fp NIL))))          (flet ((external-process-terminated ()                   (multiple-value-bind (n more)                                        (%socket-readable fp)                     (declare (ignore n))                     (not more))))            (process-wait "closing p-stream" #'external-process-terminated)             (system-pclose fp)))))    (setq *open-p-streams*           (delete stream *open-p-streams*))))(defmethod stream-abort :after ((stream p-stream))  (with-slots (fp) stream    (when fp      (setf fp NIL))))(defmethod stream-finish-output ((stream p-stream))  (without-interrupts   (with-slots (fp outcount) stream     (when (and fp (plusp outcount))       (%system-fflush fp)       (setf outcount 0))))  nil)(defMethod stream-eofp ((stream p-stream))  (with-slots (n more untyic) stream    (when (and (zerop n)(not untyic))      (or       (not more) ; avoid calling %socket-readable when we know it's eof       (progn         (multiple-value-setq (n more)           (with-slots (fp) stream             (%socket-readable fp)))         (and (or (null n)                   (zerop n))              (not more)))))))#+ignore(defmethod stream-listen ((stream p-stream))  (with-slots (fp n more untyic) stream    (when      (or untyic          (progn            (when (and (zerop n) more)              (multiple-value-setq (n more)                (%socket-readable fp)))            (plusp n)))      T)))(defmethod stream-clear-input ((stream p-stream))  ;; # implementation can be optimized!  ;; # Alternative is to use system call  (loop while (stream-listen stream)        do (stream-tyi stream)))(defmethod stream-tyi ((stream p-stream))  (or   (with-slots (untyic) stream     (when untyic       (prog1         untyic         (setf untyic NIL))))   (with-slots (fp n more) stream    (when (and fp (zerop n) more)      (stream-finish-output stream) ;; calling fflush() to avoid crashes due to bug in popen()      (multiple-value-setq (n more)        (%socket-readable fp T)))    (when (and fp n (plusp n))      (decf n)      (without-interrupts (%system-fgetc fp))))))(defmethod stream-untyi ((stream p-stream) char)  (with-slots (untyic) stream    (if untyic      (error "Two untyi's in a row")      (setf untyic char))))  (defmethod stream-tyo ((stream p-stream) c)  (with-slots (fp outcount) stream    (if fp      (without-interrupts       (%system-fputc c fp)       (incf outcount)       c)      (error "~A is closed" stream))))(defmethod stream-copy-until-eof ((in p-stream) out &optional copy-mode) ; method like those in CL-HTTP  "Reads all characters from an input stream and writes them to output stream, returning when input stream is at eof"  (declare (ignore copy-mode))  ;; # Should be optimized by using low-level block reading, fread!  (loop     until (eofp in)    for c = (read-char in nil)    while c    do (write-char c out)))(defun popen (command)   "Executes a BSD shell command in a new system process, returning a bidirectional stream that can be used to read from or write to a pipe to the process."  (make-instance 'p-stream :command command))#|(with-open-stream (ps (popen "cal"))  (loop for c = (read-char ps nil)        while c        do (if (char= c #\linefeed)             (write-char #\newline *debug-io*)             (write-char c *debug-io*))))|#(provide :popen)