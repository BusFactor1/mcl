;;;-*-Mode: LISP; Package: CCL -*-;;;;;; Fixes (R)MCL 5.2 flaw that causes save-application to not accept :size number;;;;;; Terje Norderhaug <terje@in-progress.com> ;;;;;; This software is made available AS IS, and no warranty is made about the software or its performance. (in-package :ccl)#| Replication (will cause the application to quit if successful)(defun tmpfile ()   (merge-pathnames (format nil ":~A" (random 9999999)) (findfolder #$kOnAppropriateDisk #$kTemporaryFolderType)))(fixnump (ash 1 29))(save-application (tmpfile) :size (ash 1 26))> Error in process Initial: value 67108864 is not of the expected type LIST.> While executing: CCL::OPEN-DUMPLISP-FILE|#(defun %save-application-internal (listener filename &key                                            (init-file nil init-file-p)                                            toplevel-function  ;????                                                                                         ;hide-listener                                             menubar                                            error-handler ; meaningless unless application-class or *application* not lisp-development..                                            application-class                                            creator                                             excise-compiler                                                                                        resources                                            (clear-clos-caches t)                                            memory-options                                            size)    (when (and application-class (neq  (class-of *application*)                                     (if (symbolp application-class)                                       (find-class application-class)                                       application-class)))    (setq *application* (make-instance application-class)))  (when (not creator)(setq creator (application-file-creator *application*)))  (when (not toplevel-function)    (setq toplevel-function           #'(lambda ()              (toplevel-function *application*                                  (if init-file-p                                   init-file                                   (application-init-file *application*))))))  (when error-handler    (require :hide-listener-support)    (funcall 'make-application-error-handler *application* error-handler))  (when menubar (set-menubar menubar))  #+ignore  (when size    (if (integerp size)      (setq size (list size size)))    (unless (and (listp size)                  (= (length size) 2)                  (integerp (car size))                                     (integerp (cadr size))                 (>= (car size) (cadr size) 0))      (error "Invalid ~S argument : ~S" :size size)))  (when size     (if #+ignore (fixnump size) (< size #.(ash 1 32)) ;; its size in kb      (setq *max-heap-size* size)      (error "Invalid ~S argument : ~S" :size size)))        (setq resources (append resources *patched-resources*))  (let* ((nv (new-version-resource)))    (when nv (push nv resources)))   ;; try again for OSX  (let ((cfrg (new-cfrg-resource)))    (when cfrg (push cfrg resources)))  (let* ((lsiz (process-lsiz-options memory-options)))    (when lsiz (push lsiz resources)))  (prepare-to-quit listener)  (setq *recent-files* nil)  (if clear-clos-caches (clear-clos-caches))  (if excise-compiler (excise-compiler))  (save-image (let ((vrefnum (require-type                              (volume-number (directory-namestring filename))                              'fixnum))                    (refnum (open-dumplisp-file filename creator size resources)))                #'(lambda () (%save-application vrefnum #xc0 refnum)))              ;This is a bit bogus.  Specifying an init-file arg means requesting              ;the usual lisp startup actions (load init file, print greeting and              ;run *lisp-startup-functions*).  Really should have some more              ;explicit arguments for specifying this stuff.              #'(lambda ()                  (%set-toplevel #'event-processing-loop)                  (when toplevel-function                    (if *single-process-p*                      (funcall toplevel-function)                      (process-run-function "Startup" toplevel-function))))))(defun open-dumplisp-file (filename creator &optional size resources &aux refnum resrefnum finished?)  (setq filename (create-file filename :if-exists :supersede :mac-file-creator creator                              :mac-file-type "APPL"))  (let* ((bndl (#_Get1Resource "BNDL" 128))         (bndl-p (not (%null-ptr-p bndl))))    ;(when bndl-p (#_loadresource bndl))    (unwind-protect      (with-cursor *watch-cursor*                (rletz ((fsref :fsref)                (fsspec :fsspec))          (path-to-fsref filename fsref)          (#_fsgetcataloginfo fsref 0 (%null-ptr) (%null-ptr) fsspec (%null-ptr))          (%stack-block ((pb (record-length :hparamblockrec) :clear t))            (with-pstrs ((s (pref fsspec :fsspec.name)))                              (setf (pref pb :hparamblockrec.fileparam.iovrefnum)(pref fsspec :fsspec.vrefnum)                    (pref pb :hparamblockrec.fileparam.iodirid) (pref fsspec :fsspec.parid)                    (pref pb :hparamblockrec.fileparam.ionameptr) s)              (setf (pref pb :hparamblockrec.ioparam.iopermssn) #$fswrperm)              (errchk (#_PBHOpenSync pb))              (setq refnum (pref pb :hparamblockrec.fileparam.iofrefnum))              (setf (pref pb :hparamblockrec.ioparam.iomisc) 0)  ;; (%put-long pb 0 $ioLEOF)??              (errchk (#_PBSetEOFSync pb))))                      ; Copy the resource fork          (cond            (*use-app-resources*            (copy-file (get-app-pathname) filename :fork :resource :blocksz 1024)                        (setq resrefnum (open-resource-file-from-fsref fsref #$fsRdWrPerm)) ;?                      (when (neq resrefnum -1)  ;(or size resources)              (dolist (resource resources)  ;; includes new cfrg                (if (listp resource)                  (destructuring-bind (data type id &optional (name "")) resource                    (let ((oldh (#_Get1Resource type id)))  ;; is that from currently open resource file?                      (unless (%null-ptr-p oldh)                        (#_RemoveResource oldh)))                    (when data                      (with-pstrs ((namep name))                        (#_Addresource data type id namep))))                  (funcall resource filename)))              #+ignore              (when (and (boundp '*contextual-menu-cursor*)(boundp '+contextual-menu-cursor-id+) *contextual-menu-cursor*)                ;; is there a better place to do this??? surely there must be - now there is                (with-pstrs ((namep ""))                  (#_addresource *contextual-menu-cursor* "CURS" +contextual-menu-cursor-id+ namep)))              (when t ;size                (let ((preferred-size (when (listp size) (car size)))                      (min-size (when (listp size) (cadr size))))                  ; no size provided - take from current app                  ; if size is provided use it with sanity check - perhaps warn                  (if (and preferred-size (< preferred-size (* 1024 4096)))                    (cerror "Use minimum recommended size."                            "Preferred size ~s is below recommended preferred size ~s.~&Sizes are in bytes, not kilobytes."                            preferred-size (* 1024 4096)))                  (if preferred-size (setq preferred-size (max (* 1024 4096) preferred-size)))                  (if min-size (setq min-size (max (* 1024 3584) min-size)))                  (let ((i 0)                        sizeh cur-psize cur-msize)                    ; take current sizes from last size resource                    (while (not (%null-ptr-p (setq sizeh (#_get1resource "SIZE" i))))                      (setq cur-psize (%hget-long sizeh 2))                      (setq cur-msize (%hget-long sizeh 6))                      (#_RemoveResource sizeh)                      (setq i (1+ i)))                                  (unless (%null-ptr-p (setq sizeh (#_Get1Resource "SIZE" -1)))                      (#_LoadResource sizeh)                      (%hput-word sizeh (logior #$modedisplaymanageraware (%hget-word sizeh 0)) 0)                      (%hput-long sizeh                                   (or preferred-size cur-psize (%hget-long sizeh 2))                                  2)                      (%hput-long sizeh                                  (or min-size  cur-msize (%hget-long sizeh 6))                                   6)                      (#_ChangedResource sizeh)))))              (when (integerp size)                (assert (< size #.(ash 1 32)))                (let ((handle (#_Get1Resource "NSIZ" 1)))                  (unless (%null-ptr-p handle)                    (#_RemoveResource handle))                  (setf (%hget-unsigned-long handle 0) size)                  (with-pstrs ((namep ""))                    (#_Addresource handle "NSIZ" 1 namep))))))            (t (let* ()                                (with-open-resource-file (refnum filename :if-does-not-exist :create)                  ;; cfrg vers and bndl - icons?                  (using-resource-file refnum                    (with-pstr (namep "")                      (when bndl-p                        ;; (#_addresource bndl "BNDL" 128 namep)  ;; doesn't work - err -54                        )                      (#_AddResource (#_newhandle 0) "carb" 0 namep)) ;; need for not open in classic                    (dolist (res resources)                      (when (listp res)                        (destructuring-bind (data type id &optional (name "")) res                          (when (or (eq type :|cfrg|)(eq type :|vers|))                            (with-pstrs ((namep name))                              (#_Addresource data type id namep)))))))))))          (let* ()            (rletZ ((catinfo :fscataloginfo))              (fsref-get-cat-info fsref catinfo #$kFSCatInfoFinderInfo)              (let ((flags (pref catinfo :FSCataloginfo.FinderInfo.finderflags)))                (declare (fixnum flags))                (setf (pref catinfo :FSCataloginfo.FinderInfo.finderflags)                      (if (or bndl-p (not *use-app-resources*)) ;; ??                        (logior flags #$kHasBundle)                        (logand flags (lognot #$kHasBundle))))                (fsref-set-cat-info fsref catinfo #$kFSCatInfoFinderInfo))))          (setq finished? t)))    ; unwind-protect cleanup forms          (When (and resrefnum (neq resrefnum -1)) (#_CloseResFile resrefnum))    ;(print finished?)    (unless finished?      (when refnum                (rletZ ((pb :hparamblockrec))          (setf (pref pb :hparamblockrec.ioparam.iorefnum) refnum)          (errchk (#_PBCloseSync pb)))))))  refnum)